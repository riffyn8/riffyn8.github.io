---
layout: post
title: 3.운영체제
date: 2026-02-24
categories: [자격증, 정보처리기사]
sitemap: false
math: true
media_subpath: /assets/img/posts/
comments: false
---

### UNIX
미국 AT&T 벨 연구소에서 개발. C언어로 작성되어 이식성이 높고 장치 간 호환성이 우수
- 다중 사용자, 다중 작업 가능
- 계층적 트리 구조 파일 시스템 
- 사용자의 명령에 즉각 반응하는 대화식 운영체제

### UNIX 시스템 구조 
- **커널(Kernel)**: UNIX의 가장 핵심적인 부분. 컴퓨터가 부팅될 때 주기억장치에 적재된 후 상주하면서 실행된다. (하드웨어 보호, 서비스, 프로세스, 메모리, 파일 관리 등 수행)
- **쉘(Shell)**: 사용자의 명령어를 인식하여 프로그램을 호출하고 명령을 수행하는 명령어 해석기
- **유틸리티(Utility Program)**: 응용 프로그램을 처리하는 데 사용

### 파일과 디렉토리 권한 설정
1. **권한 설정 대상**: `소유자(User/Owner), 그룹(Group), 일반 사용자(Others)`
2. **8진수 모드:** `4 (읽기, r)`, `2 (쓰기, w)` , `1 (실행, x)`
3. **chmod**: 8진수 모드 기반으로 권한을 <u>부여/설정</u>
   - 일반 파일은 `-`, 디렉토리는 `d`
   - 예: `chmod 754` → **7**(소유자), **5**(그룹), **4**( 일반 사용자)
   - 예: rw- r-- rwx → **6**(소유자), **4**(그룹), **7**( 일반 사용자)
4. **umask**: 8진수 모드 기반으로 권한을 <u>제거/차단</u>
   - 디렉터리의 기본 권한은 777, 파일의 기본 권한은 666 
   - umask 022 → 파일: **6**(소유자),**4**(그룹),**4**( 일반 사용자) / 디렉토리: **7**(사용자), **5**(그룹), **5**(기타)

### 프로세스
메모리에 적재되어 실행되고 있는 프로그램

### 프로세스 상태 전이
![프로세스상태전이](process1.png)

- **Dispatch**: 준비 상태의 프로세스가 실행 상태로 변경
- **Wake Up**: 입 · 출력 작업이 완료되어 프로세스가 대기 상태에서 준비 상태로 전이
- **Spooling**: 입 · 출력장치의 처리 속도를 보완하고, 다중 프로그래밍 성능을 향상시키기 위해 디스크에 저장하고 한꺼번에 출력하는 것
- **교통량 제어기(Traffic Controller)**: 프로세스의 상태에 대한 조사와 통보를 담당

### 인터럽트
수행 중인 프로세스가 특정 요인에 의해 일시 중지되었다가 다시 복귀하는 것
- **외부 인터럽트**: 입출력 장치, 전원 이상 등의 외부적인 요인에 의해 발생
- **내부 인터럽트**: 잘못된 명령이나 데이터를 사용할 때 발생
- **소프트웨어 인터럽트**: 요청에 의해 발생하는 인터럽트. SVC(Supervisor Call)가 대표적

### IPC (프로세스 통신)
직접적인 통신 방법이 없는 프로세스들이 통신을 하기 위해 사용하는 특별한 기법
- 모듈 간 통신 방식을 구현하기 위해 사용되는 대표적인 프로그래밍 인터페이스 집합
- **공유 메모리(Shared Memory)**: 다수의 프로세스가 공유 가능한 메모리를 구성하여 프로세스 간 통신을 수행
- **소켓(Socket)**: 네트워크를 통해 서로 다른 컴퓨터에 있는 프로세스 간 통신을 가능하게 함 (TCP/IP 활용)
- **세마포어(Semaphores)**: 공유 자원에 접근할 때 프로세스 간 동기화 및 상호배제를 제어하기 위한 수단
- **파이프(Pipe)**: 단방향 통신 채널. 한쪽에서 쓰고 다른 쪽에서 읽음
- **메시지 큐(Message Queue)**: 메시지를 큐 형태로 전달하는 방식. 비동기적이며, 메시지 단위로 통신

### 스레드
프로세스 내에서 실행되는 흐름의 단위로 경량 프로세스라고도 한다.

| 구분            | 사용자 수준 스레드 (User-Level) | 커널 수준 스레드 (Kernel-Level)  |
|---------------|-------------------------|---------------------------|
| 관리 주체         | 사용자가 작성한 라이브러리가 관리      | 운영체제(커널)가 직접 관리           |
| 커널의 인지        | 커널은 스레드의 존재를 모름         | 커널이 스레드 하나하나를 다 알고 있음     |
| 모드 전환         | 커널 모드 전환 없이 사용자 모드에서 교환 | 스레드 교환 시 커널 모드 전환 필요      |
| 속도(오버헤드)      | 매우 빠름 (전환 비용이 거의 없음)    | 상대적으로 느림 (커널 개입 때문)       |
| I/O 차단(Block) | 스레드 하나가 멈추면 전체 프로세스가 멈춤 | 스레드 하나가 멈춰도 다른 스레드는 계속 일함 |
| 병렬 처리         | 멀티프로세서(여러 CPU) 활용 불가    | 멀티프로세서 활용 가능 (병렬 처리)      |

### 프로세스 스케줄링
CPU 할당을 위해 프로세스들 사이의 우선 순위를 부여, 관리하는 것
- 비선점형(중단 불가): 일괄 처리 중심. `FIFO, SJF, HRN`
- 선점형(중단 가능): 실시간 처리 중심. `RR, SRT, MFQ`
- **종료 시간**: 프로세스가 완전히 일을 마치고 CPU를 떠나는 시간
- **서비스 시간(실행 시간)**: 프로세스가 CPU를 점유해서 실제로 일하는 시간
- **반환 시간**: 프로세스가 도착하여, 실행이 종료될 때까지 걸린 총 시간
  - 공식 1: $종료시간-도착시간$
  - 공식 2: $대기시간+서비스시간$
- **대기 시간**: 프로세스가 도착 후, 실행 전까지 대기한 시간
  - 공식1: $실행 시작 시간 - 도착 시각$
  - 공식2: $반환 시간 - 실행 시간$ 
- **계산 검증**: $평균 대기 시간 + 평균 실행 시간 = 평균 반환 시간$

### FIFO
프로세스가 도착한 순서대로 처리. 평균 반환 시간이 길다

#### FIFO 예제
평균 반환 시간, 평균 대기 시간, 평균 실행 시간을 구하시오

| 프로세스 | 도착시간 | 실행 시간 |
| ---- | ---- | ----- |
| P1   | 0    | 5     |
| P2   | 2    | 8     |
| P3   | 4    | 3     |

- 평균 반환 시간 = 12/3 = 4
- 평균 대기 시간 = 28/3
- 평균 실행 시간 = 16/3

> P1, P2, P3의 실행 흐름을 먼저 파악해야 한다. <br/>
> P1은 0초에 도착하자마자 실행되어 5초에 종료되고, 이어서 P2가 실행되어 13초(5+8)에 종료되며, 마지막으로 P3가 실행되어 16초(13+3)에 종료된다. <br/>
> - 반환 시간: 프로세스가 종료된 시간 - 도착 시간 
> - 대기 시간: 프로세스가 실행을 시작한 시점 - 도착 시간
> - 평균 실행 시간: (P1 실행 시간 + P2 실행 시간 + P3 실행 시간 ) / 프로세스 개수(3)

### SJF
실행 시간이 가장 짧은 프로세스 순으로 처리
- 실행 시간이 길어도 도착 시간이 0인 프로세스를 먼저 실행(비선점형이므로)

#### SJF 예제
평균 반환 시간, 평균 대기 시간, 평균 실행 시간을 구하시오

| 프로세스 | 도착 시간 | 실행 시간 |
| :--- | :---- | :---- |
| P1   | 0     | 8     |
| P2   | 2     | 4     |
| P3   | 3     | 2     |

- 평균 반환 시간 = 27/3 = 9
- 평균 대기 시간 = 13/3
- 평균 실행 시간 = 14/3

> 실행 흐름: 0초(P1 실행) → 8초(P1 종료 / P3 실행) → 10초(P3 종료 / P4 실행) → 14초(P4 종료)

### HRN 
FIFO와 SJF의 단점을 보완. 우선 순위를 높여서 긴 작업과 짧은 작업 간의 지나친 불평등을 해소
- 우선순위 공식 $= (대기 시간 + 실행 시간) / 실행 시간$
- 계산 결과가 큰 작업에 높은 우선순위를 부여

#### HRN 예제 
다음에 실행될 프로세스는? (P1이 실행을 마치고 종료된 시점은 10이다.)

| 프로세스 | 도착 시간 | 서비스 시간 |
| :--- | :---- | :----- |
| P2   | 2     | 8      |
| P3   | 4     | 4      |
| P4   | 6     | 2      |

**✔️ P4**

> 우선순위 공식: $(실행시간+대기시간)/실행시간$ </br>  
> 대기 시간은 '실행 시작 시점'에서 '도착 시간'을 뺀 값이다. 즉, P1이 종료된 시점인 10이 다음 프로세스들의 실행 대기 기준 시점이 된다. <br/> 
> `10 - 도착시간`을 계산하면 각 프로세스의 대기 시간을 구할 수 있다.

### RR
동일한 Time Slice를 사용하는 시분할 처리 시스템에 효과적으로 적용. 계산 방식은 FIFO와 동일
- 도착한 순서대로 실행은 되지만, 할당된 시간만큼 실행되고 바로 넘어감

#### RR 예제
시간 할당량이 3초일 때, 평균 반환 시간, 평균 대기 시간, 평균 실행 시간은?

| 프로세스 | 도착 시간 | 실행(서비스) 시간 |
| ---- | ----- | ---------- |
| P1   | 0     | 7          |
| P2   | 2     | 4          |
| P3   | 4     | 2          |

- 평균 반환 시간 = 27/3 = 9
- 평균 대기 시간 = 13/3
- 평균 실행 시간 = 14/3

> 실행 흐름
> - P1 (0~3): 3초 실행. (잔여 4초)
> - P2 (3~6): 3초 실행. (잔여 1초)
> - P3 (6~8): 3초 실행. (종료) 
> - P1 (8~11): 3초 실행. (잔여 1초)
> - P2 (11~12): 1초 실행. (종료)
> - P1 (12~13): 1초 실행. (종료)

> 선점형에서는 프로세스의 실행 시작 시점이 명확하지 않기에 `반환 시간-실행 시간` 공식을 사용

### SRT
작업이 끝나지 않은 프로세스의 남아 있는 실행 시간이 가장 작은 프로세스를 먼저 실행.
- SJF를 선점 형태로 변경한 기법. 점유 시간이 길어도 중요한 프로세스를 먼저 할당할 수 있다.
- 도착 시간 기준으로 실행 시간을 비교해서 더 짧은 프로세스를 먼저 실행

#### SRT 예제
평균 반환 시간, 평균 대기 시간, 평균 실행 시간을 구하시오

| 프로세스 | 도착 시간 | 실행 시간 |
| :--- | :---- | :---- |
| P1   | 0     | 6     |
| P2   | 2     | 2     |
| P3   | 4     | 5     |

- 평균 반환 시간 = 19/3
- 평균 대기 시간 = 6/3 = 2
- 평균 실행 시간 = 13/3

> 실행 시간
> - P1 (0~2): 2초 실행. (잔여 4초, P2가 도착했으므로 실행 시간 비교. P1 > P2  → P2 실행)
> - P2 (2~4): 2초 실행 (종료)
> - P1 (4~8): 4초 실행 (종료, P3가 도착했으므로 실행 시간 비교. P1 < P3 → P1 실행)
> - P3 (8~13): 5초 실행 (종료)

### MFQ
짧은 작업이나 입출력 위주의 프로세스에 우선순위를 부여하기 위해 개발

### 교착상태(Dead Lock)
다수의 프로세스가 같은 자원의 할당을 요구하며 무한정 기다리고 있는 상태

### 교착상태 발생의 필요 충분 조건
- **상호 배제(Mutual Exclusion)**: 한 번에 한 개의 프로세스만이 공유 자원을 사용할 수 있어야 함
- **점유와 대기(Hold and Wai)**: 프로세스가 하나 이상의 리소스를 점유하고 있으면서 다른 프로세스가 가지고 있는 리소스를 기다리는 상태
- **비선점(Non-Preemption)**: 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없어야 한다.
- **환형 대기(Circular Wait)**: 각 프로세스가 순차적으로 다음 프로세스가 요구하는 자원을 가진 상태

### 교착상태 해결 방법
1. **예방(Prevention)**: 교착상태 발생의 네 가지 조건 중에서 어느 하나를 제거(부정)하여 예방
2. **회피(Avoidance)**: 교착상태 발생 가능성을 회피하여 예방. 대표적으로 다익스트라 은행원 알고리즘
3. **발견(Detection)**: 교착상태에 있는 프로세스와 자원을 발견하는 것.
4. **회복(Recovery)**: 교착상태가 발생한 프로세스 중 중단할 프로세스를 정하여 자원을 빼앗음

### 주기억장치
- **RAM**: 휘발성. 실행 중인 프로그램 저장
- **ROM**: 비휘발성. 하드웨어와 소프트웨어의 중간인 일종의 펌웨어이다. 부팅 시 가장 먼저 동작하며 자체 진단(POST) 실행

### 단편화(Fragmentation)
주기억 장치에서 공간의 할당 및 반납에 따라 공간들이 조각나 사용하지 못하게 되는 공간
- **내부 단편화**: 데이터 및 프로그램을 할당하고 남은 공간
- **외부 단편화**: 데이터 및 프로그램의 크기가 커서 할당되지 못하는 공간
- **해결 방안**: `통합, 압축`

### 주기억 장치 관리 전략
CPU가 접근해야 할 데이터를 보조기억 장치에서 주기억 자잋로 적재하는 것
1. **반입(Fetch) 전략**: 데이터를 <u>언제 주기억 장치로 적재</u>할 것인지를 결정
2. **배치(Placement) 전략**: 데이터를 주기억 장치의 <u>어디에 적재</u>할 것인지를 결정
   - **최초 적합(First Fit)**: 첫 번째 공간에 배치
   - **최적 적합(Best Fit)**: 단편화가 가장 적게 남는 공간에 배치
   - **최악 적합(Worst Fit)**: 단편화를 가장 많이 남기는 공간에 배치
3. **교체(Replacement) 전략**: 주기억 장치의 모든 영역이 사용 중인 상태에서 기존<u> 데이터 중 어느 것을 교체</u>할 것인지를 결정

### 연속 할당 기법
프로세스의 주기억장치의 연속된 공간에 통째로 적재하는 방식
- **단일 분할 할당**: 한 번에 한 프로그램만 적재
  - **오버레이**: 주기억 장치보다 큰 프로그램 실행을 위해 프로그램을 분할하여 필요할 때마다 교체
  - **스와핑**: 프로그램 전체를 적재하여 사용하다가 교체 <br/> (`Swap In`: 보조 기억 장치 → 주기억 장치, `Swap Out`: 주기억 장치 → 보조기억 장치)
- **다중 분할 할당**: 여러 프로그램을 동시에 적재
  - **고정 분할(MFT)**: 미리 고정된 크기로 나눔 (내/외부 단편화 발생)
  - **가변 분할(MVT)**: 실행 시 필요한 만큼만 나눔 (외부 단편화 발생)

### 가상 기억장치
보조기억 장치의 일부를 주기억 장치처럼 사용하여 용량이 큰 프로그램을 실행할 수 있도록 하는 기법
- 스와핑 기법에서 발전된 것으로, 연속 할당 방식에서 발생하는 단편화 문제를 해결할 수 있다.

### 페이징(Paging) 기법
프로그램을 똑같은 크기의 페이지(Page)로 나누고, 주기억장치를 똑같은 크기의 프레임(Frame)으로 나누어 적재
- 페이지 맵테이블을 사용하여 주소를 변환한다. 
- 내부 단편화가 발생한다. 

> 필요한 페이지들만 메모리에 올려서 실행할 수 있어 단편화를 줄이고 메모리 활용을 높인다.

### 세그먼테이션(Segmentation) 기법
프로그램을 다양한 크기의 논리적인 세그먼트(Segment) 단위로 나눈 후, 주기억장치에 적재
- 위치 정보를 저장하는 세그먼트 맵 테이블과 서로의 영역을 침범하지 않게 하는 장치(기억장치 보호)가 필요 
- 외부 단편화가 발생한다.

> 세그먼트의 크기는 가변적이므로 각각의 위치와 크기 정보를 별도로 관리해야 한다. 이를 통해 특정 세그먼트가 다른 세그먼트의 영역을 침범하지 않도록 메모리 보호를 수행해야 하는 것

### 페이지 교체 알고리즘
1. **OPT(최적 교체)**
   - 가장 오랫동안 사용하지 않을 페이지를 교체 (페이지 부재 횟수가 가장 적게 발생)
   - 이론적으로는 완벽하지만 현실적으로는 구현이 어렵다.
2. **FIFO**: <u>가장 먼저 적재된</u>(오래된) 페이지를 교체
3. **LRU**: <u>최근에 가장 오랫동안 사용하지 않은</u> 페이지를 교체 (시간을 기준으로 페이지를 교체)
4. **LFU**: <u>사용 빈도가 가장 적은</u> 페이지를 교체 (호출된 횟수가 가장 적은 페이지를 교체)
5. **NUR**:
   - <u>최근에 사용하지 않은 페이지</u>를 교체하는 기법 
   - 최근 사용 여부를 확인하기 위해서 각 페이지마다 참조 비트와 변형 비트를 사용한다. 
   - 참조 비트: 호출되지 않았을 때 0, 호출되었을 때 1 
   - 변형 비트: 변형되지 않았을 때 0, 호출되었을 때 1

   | 우선순위      | 참조 비트 | 변형 비트 | 의미                     |
   | --------- | ----- | ----- | ---------------------- |
   | 1순위 (최우선) | 0     | 0     | 최근에 참조되지도, 수정되지도 않음    |
   | 2순위       | 0     | 1     | 최근에 참조되지 않았으나, 수정은 되었음 |
   | 3순위       | 1     | 0     | 최근에 참조되었으나, 수정은 되지 않음  |
   | 4순위       | 1     | 1     | 최근에 참조되었고, 수정도 되었음     |   

6. **SCR**: FIFO의 단점을 보완하는 기법. 오랫동안 주기억 장치에 있던 페이지 중 자주 사용되는 페이지의 교체를 방지하기 위한 기법
7. **페이지 적중률(Hit Ratio)**: 1 - (페이지 부재 횟수 / 참조 횟수) (100을 곱하면 %)

### 페이지 크기에 따른 변화

| 구분       | 페이지 크기 ↓ | 페이지 크기 ↑ |
|----------|----------|----------|
| 내부 단편화   | 감소       | 증가       |
| 맵 테이블 크기 | 증가       | 감소       |
| 참조 구역성   | 일치       | 불일치      |
| 매핑 속도    | 느림       | 빠름       |
| 입출력 효율   | 낮음       | 높음       |

### 구역성(Locality)
프로세스가 특정 페이지를 집중적으로 참조하게 되는 특성
- **시간(Temporal) 구역성**: 특정 페이지를 일정 시간 동안 집중적으로 접근 (Loop, Stack, 부프로그램, 집계)
- **공간(Spatial) 구역성**: 특정 위치의 페이지를 집중적으로 접근 (배열, 순차적 코드 실행)

### 스레싱(Thrashing)
CPU의 이용률이 저하되고, 페이지 부재가 빈번해져 페이지 교체 시간이 실제 프로세스 수행 시간보다 길어지는 현상
- 방지 대첵: 다중 프로그래밍의 정도를 낮춤, 워킹셋 유지, 페이지 부재 빈도 조절
- **워킹 셋(Working Set)**: 프로세스가 특정 단위 시간 동안 자주 참조하는 페이지들의 집합

### 파일 설계(파일 편성)
- **순차(Sequential) 편성**: 데이터를 입력된 논리적 순서대로 물리적 연속 위치에 기록 
- **직접(Direct) 편성, 임의(Random) 편성**: 해싱 함수로 키를 주소로 변환하여 키 순서와 상관없이 임의로 기록. 처리 속도가 일정하다
- **색인 순차(Indexed Sequential) 편성**: 데이터를 순차적으로 기록하고, 별도의 색인을 구성하여 순차 처리와 임의 처리를 모두 지원

### FCB
운영체제가 특정 파일에 접근할 때 파악되어야 할 파일의 관리 정보를 저장해둔 블록

### RAID
다수의 하드 디스크 드라이브를 하나의 드라이브처럼 사용하는 방식

### 디스크 스케줄링
1. **FCFS**: 입출력 데이터 요청이 들어온 순서대로 처리
2. **SSTF**: 현재 디스크 헤드에서 가장 가까운 트랙의 요청을 먼저 처리
3. **SCAN**: 현재 디스크 헤드가 진행되는 방향에 있는 요청을 전부 처리한 뒤, 반대 방향에 있는 요청을 처리
4. **C-SCAN**: 항상 바깥쪽 트랙에서 안쪽 트랙으로 진행하며 요청을 처리
5. **LOOCK**, **C-LOOK**: SCAN과 C-SCAN을 보완한 방식. 진행 방향의 요청이 없는 경우 양단까지 진행하지 않고 방향을 전환하여 처리
