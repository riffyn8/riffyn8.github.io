---
layout: post
title: 1.소프트웨어 구축
date: 2026-02-23
categories: [자격증, 정보처리기사]
sitemap: false
math: true
media_subpath: /assets/img/posts/
comments: false
---

## 1) 소프트웨어 개발 방법론
### 소프트웨어 종류
1. **상용 소프트웨어**: 상업적 목적으로 개발되는 소프트웨어
2. **응용 소프트웨어**: 특정 업무를 처리하기 위한 목적으로 작성된 소프트웨어
3. **시스템 소프트웨어**
   - 사용자가 손쉽고 효율적으로 컴퓨터 시스템을 사용하도록 돕는 소프트웨어
   - **시스템의 5요소**: 입력, 처리, 출력, 제어, 피드백
   - **시스템 소프트웨어 구성**
     - 제어 프로그램: 감시, 작업 제어, 데이터 관리
     - 처리 프로그램: 언어 번역, 서비스, 문제 해결
   - **성능 평가 기준** <br/> 
     - **처리능력(Throughput)**: 일정 시간 내에 시스템이 처리하는 작업의 양 
     - **반환 시간(Turnaround Time)**: 사용자가 작업을 제출한 시점부터 결과가 최종적으로 출력될 때까지 걸린 시간
     - **가용성(Availability)**: 시스템을 필요로 할 때 즉시 사용할 수 있는 정도
     - **신뢰도(Reliability)** : 주어진 시간 동안 시스템이 고장 없이 정확하게 기능을 수행하는 정도
4. **플랫폼**
   - 특정 시스템을 바탕으로 제공되는 운영체제 및 운영환경
   - **성능 측정 기준** <br/>
     - **가용성(Availability)**: 필요한 시점에 지체 없이 사용할 수 있는 정도
     - **응답 시간(Response Time)**: 요청을 전달한 시점부터 시스템의 반응이 시작될 때까지의 걸린 시간
     - **정확성(Accuracy)**: 결과가 얼마나 실제 데이터(기대값)와 일치하는지 나타내는 정도
     - **사용률(Utilization)**: 시스템의 자원이 실제 작업에 어느 정도 사용되고 있는지를 나타내는 비율

> 반환 시간과 응답 시간
> - 반환시간: 작업 의뢰부터 처리까지의 시간
> - 응답 시간: 명령에 반응하는 시간

### 소프트웨어 재사용 단위
1. **모듈(Module)**: 프로그램을 기능별로 분할하여 재사용이 가능하게끔 부품화 한 것
2. **라이브러리(Library)**: 관련 있는 모듈들을 모아놓은 것
3. **컴포넌트(Component)**: 모듈의 형태로 재사용 가능한 확장된 소프트웨어
4. 소프트웨어 재사용 방법
   - **합성(Composition)**: 모듈을 조립하여 소프트웨어를 완성하는 블록 구성 방식
   - **생성(Generation)**: 추상적인 명세를 구체화하여 소프트웨어를 완성하는 패턴 구성 방식

> 모듈 + 모듈 = 라이브러리 <br/>
> 모듈 $\neq$ 컴포넌트

### 소프트웨어 개발 생명 주기
소프트웨어 개발 과정을 단계별로 구성한 것으로 단계별 산출물이 존재 <br>
`프로젝트 계획 → 요구 분석 → 설계 → 구현 → 테스트 → 유지 보수`

### 소프트웨어 개발 생명 주기 모델
1. **폭포수(Waterfall)**
   - 과거에 가장 폭넓게 사용되던 방식으로 이전 단계로 돌아갈 수 없다.
   - 단계별로 결과물이 명확하게 산출되어야 다음 단계로 넘어가는 방식 (선형 순차적 개발)
2. **프로토타입(Prototype)**
   - 시제품을 통해 최종 결과물을 예측할 수 있다
   - 사용자와 시스템 사이의 인터페이스에 중점을 두어 개발
3. **나선형(Spiral)**
   - 여러 번의 지속적인 개발 과정을 통해 점진적으로 개발하는 것
   - `계획 및 목표 설정 → 위험 분석 → 공학적 개발 및 검증 → 고객 평가` 
4. **애자일**
   - 소프트웨어를 사용할 고객과의 소통에 중심을 둔 방법론들의 통칭
   - 짧은 개발 주기를 반복하면서 고객의 피드백을 소프트웨어에 반영
   - 애자일 선언문
     - 프로세스 도구보다 개인과 상호작용을
     - 방대한 문서보다 실행되는 소프트웨어를
     - 계약 협상보다 고객과의 협력을
     - 계획을 따르는 것보다 변화에 대응을

### 스크럼
스크럼 팀을 구성하여 팀을 중심으로 개발의 효율성을 높이는 개발 모델로, 반복적인 스프린트를 통해 제품을 완성시켜 나간다.
1. 구성원
   - **제품 책임자(Product Owner)**: 이해관계자들의 의견을 종합하여 요구사항을 백로그에 작성하고 우선순위를 결정
   - **스크럼 마스터(Scrum Master)**: 팀이 스크럼을 원활히 수행하도록 돕는 조력자 역할
   - **개발팀(Development Team)**: 제품 책임자와 스크럼 마스터를 제외한 나머지 인원
2. 개발 프로세스: `계획 회의 → 스프린트 진행 → 일일 스크럼 회의 → 검토 회의 → 회고`
3. 주요 용어
   - **스프린트**: 실제 제품 개발이 이루어지는 고정된 짧은 기간 (2~4주)
   - **제품 백로그**: 제품 전체에 필요한 모든 요구사항을 우선순위에 따라 나열한 목록
   - **스프린트 백로그**: 스프린트 동안 팀이 완료하기로 결정한 상세 작업 목록

> 소멸차트(Burn-down Chart)는 진행 상황을 시각화하는 도구이며, 스크럼의 산출물이 아님

### XP(Extreme Programming)
고객의 참여와 짧은 개발 과정의 반복을 극대화하여 개발 생산성을 높이는 개발 모델
1. **핵심 가치**: <u>의사소통, 단순성, 용기, 존중, 피드백</u>
2. 개발 프로세스: `사용자 스토리(User Story) → 계획(Planning) → 반복(Iteration) → 릴리즈(Release)`
3. XP의 기본 원리

   | 용어                                     | 설명                                    |
   |----------------------------------------|---------------------------------------|
   | **Planning Game(계획 세우기)**              | 게임처럼 선수, 규칙 목표 등을 설정하여 계획 수립          |
   | **Small Releases(소규모 릴리즈)**            | 짧은 주기의 릴리즈로 고객의 피드백 최대화               |
   | **Metapho**                            | 개발 과정에서 최종 목표 시스템의 구조를 조망             |
   | **Simple Design**                      | 가능한 가장 단순한 설계                         |
   | **Test Driven Development(테스트 주도 개발)** | 단위 테스트 진행 후 실제 코드 작성                  |
   | **Refactoring**                        | 기능 변경 없이 코드의 구조를 개선하여 유연성과 가독성을 높임    |
   | **Pair Programming(짝 프로그래밍)**          | 2명의 개발자가 코딩, 리뷰 공동 수행                 |
   | **Collective Ownership(공동 코드 소유)**     | 팀 내 누구든지 시스템의 어떤 코드라도 수정하고 개선할 권한을 가짐 |
   | **Continuous Integration(지속적 통합)**     | 항상 빌드 및 배포가 가능한 상태 유지                 |
   | **40-Hour Week(주 40시간 근무)**            | 과도한 연장 근로를 지양 |
   | **Whole Team(전체 팀)**                   | 개발 효율을 위해 고객을 프로젝트 팀원으로 상주시킴 |
   | **Coding Standards(코드 표준)**            | 원활한 의사소통을 위해 표준화된 관례에 따라 코드 작성 |

### CASE
소프트웨어 개발 프로세스의 전 과정에서 자동화를 지원하는 소프트웨어 도구
- **주요 특징**: 표준화, 생산성 향상, 품질 향상, 유지보수 용이, 재사용성
- **원천 기술**: 구조적 기법, 프로토타이핑, 자동 프로그래밍, 정보 저장소, 분산 처리
- **SADT**: SoftTech 사에서 개발한 구조적 분석 및 설계 도구
- **SREM**: TRW 사에서 개발한 RSL(언어)과 REVS(시스템)를 사용하는 요구 분석용 자동화 도구
- **TAGS**: 시스템 공학 방법 응용에 대한 자동 접근 방법으로 개발 주기의 전 과정에 이용할 수 있는 통합 자동화 도구
- **PSL/PSA**: 미시간 대학에서 개발한 PSL(언어)과 PSA(시스템)를 사용하는 요구 분석용 자동화 도구

> CASE 도구 간에 호환성은 좋지 않음

---

## 2) 프로젝트 계획
### 테일러링
개발 프로젝트의 특성 및 필요에 따라 기존의 소프트웨어 개발 모델을 <u>최적화하는 활동</u>
- **내부적 요건**: 목표 환경, 요구사항, 프로젝트 규모, 보유 기술 등
- **외부적 요건**: 법적 제약사항, 표준 품질 기준 등

### 소프트웨어 개발 관리 요소(3P)
- 인적 자원(**P**eople)
- 일정(**P**rocess)
- 문제(**P**roblem)

### WES
프로젝트의 전체 범위를 하위 계층으로 분할하여 관리하는 계층적 작업 구조

### 프로젝트 일정 관리
1. **Brooks의 법칙**: 프로젝트 진행 중에 새로운 인원을 투입할 경우 오히려 일정을 지연시킴
2. **PERT**
   - <u>작업별 개발 기간이 불확실</u>하여 개발 기간 내에 전체 프로젝트를 완료할 수 있을지에 대한 확률을 분석할 때 사용
   - 낙관치, 기대치, 비관치를 이용하여 예측치를 계산한다.
   - $예측치 = (낙관치 + 4 × 기대치 + 비관치)/6$
3. **CPM**
   - <u>작업별 개발 기간이 확실</u>한 경우에 사용. 임계 경로 기법이라고도 한다.
   - 임계 경로: 작업 소요시간이 가장 오래 걸리는 경로
4. **간트 차트**: 프로젝트 개발 일정을 기능별로 시간의 흐름에 따라 막대 그래프를 사용하여 표현한 일정표

#### PERT 예제1
어떤 작업의 소유 시간이 다음과 같을 때, PERT 기법에 의한 기대 시간(예측치)을 구하시오
- 낙관치: 3일
- 기대치(최빈치): 6일
- 비관치: 15일

답: 예측치 = (3+4×6+15)/6 = 7

#### CPM 예제1
![cpm 예제](cpm1.png){ .normal }
_○ 노드: 작업 / □ 이정표 / → 간선: 전후 의존 관계_

- 경로1: 2일 + 2일 + 3일 + 3일 = 10일
- **✔️경로2: 2일 + 3일 + 5일 + 4일 = 14일 (최장 경로=임계 경로)** 
- 경로3: 3일 + 5일 + 4일 = 12일

### 하향식 비용 산정 기법
과거의 유사한 개발 경험을 기반으로 비용을 산정하는 비과학적인 방법. 소프트웨어의 전체 비용을 산정한 뒤 각 기능별로 세분화한다.
1. **전문가 측정 기법**: 경험이 있는 둘 이상의 전문가들이 신속하게 비용을 산정하는 것
2. **델파이 측정 기법**: 조정자가 여러 전문가의 의견을 종합하여 비용을 산정

### 상향식 비용 산정 기법
프로젝트 세부 작업 단위별로 비용을 산정 한뒤 전체 비용을 산정하는 방식
- 종류: LOC, 단계별 노력 기법, 수학적 산정 기법

### LOC
각 기능의 소스코드 라인 수의 비관치, 낙관치, 기대치를 통해 예측치를 계산하고 이를 기반으로 비용을 산정
- **노력(Effort, 인월, Man-Month)[^1]** $=개발 기간 × 투입 인원 = {전체 LOC ÷ 1인당월평균생산성}$ 
- **개발 비용[^2]** $=노력×월평균 인건비$
- **개발 기간[^3]** $={노력 ÷ 투입 인원}$
- **생산성[^4]** $={전체 LOC ÷ 노력}$  

#### 예제1
소프트웨어 개발 프로젝트의 총 라인수가 50,000 LOC이고, 개발자로 참여하는 인원이 10명이다. 개발자들의 1인당 월평균 생산성이 500 LOC일 때, LOC 기법에 의한 개발 기간(개월)을 계산하시오.

**✔️개발 기간: 10개월**
> 노력 = 50000 / 500 = 100 <br/>
> 개발 기간 = 100 / 10 = 10


#### 예제2
다음은 LOC 기법을 이용한 비용 산정 모델의 기초 자료이다. 예측 LOC와 노력(인월)을 각각 계산하시오.
- 낙관치: 15,000 라인
- 비관치: 45,000 라인
- 기대치(중간치): 30,000 라인
- 1인당 월평균 생산성: 1,000 라인

**✔️ LOC: (15000+4×30000+45000)/6 = 30,000** <br/>
**✔️ 노력: 30000 / 1000 = 30**

#### 예제3
어느 소프트웨어 개발에 소요되는 노력을 산정한 결과 60인월(Man-Month)이 계산되었다. 이 프로젝트에 5명의 개발자가 투입되고, 개발자의 1인당 월평균 인건비가 400만 원일 때, 다음을 계산하시오.

**✔️ 개발 기간(개월): 60/5 = 12** <br/>
**✔️ 총 개발 비용(원): 60 × 400 = 24,000 (2억 4천)**

> 개발 비용 계산에 사용되는 인월 자체에 인원수가 포함되어 있으므로, 1인당 월평균 인건비만 곱하면 됨

### 수학적 산정 기법
1. **COCOMO**
   - 보헴이 제안한 LOC 기반 비용 산정 기법
   - **Organic(조직형)**: 중, 소규모. 5만 라인 이하. 사무처리, 업무용, 과학 응용 소프트웨어
   - **Semi-Detached(반 분리형)**: 30만 라인 이하의 운영체제, DBMS, 트랜잭션 처리 시스템
   - **Embedded(내장형)**: 30만 라인 이상의 초대형 규모의 시스템. 임베디드 시스템
2. **Putnam**: 푸트남이 제안한 비용 산정 기법으로 시간에 따른 함수로 표현되는 레일리-노든 곡선의 노력 분포도에 기반한다. (자동화 비용 측정 도구는 `SLIM`)
3. **기능 점수(FP)**: 알브레히트가 제안한 기법으로 소프트웨어 기능을 증대시키는 요인별로 가중치를 부여하여 비용을 산정. (자동화 비용 측정 도구는 `ESTIMACS`)

----

## 3) 요구사항 분석
### 현행 시스템 파악
목표 시스템의 개발 범위 및 방향성을 정의하기 위해 현재 운행되는 시스템의 구성을 파악하는 활동

| 단계  | 주요 파악 내용           | 핵심 키워드                           |
| --- | ------------------ | -------------------------------- |
| 1단계 | 구성, 기능, 인터페이스 파악   | 하위 시스템 구성, 주요 기능, 데이터 주고받는 방식 파악 |
| 2단계 | 아키텍쳐 및 소프트웨어 구성 파악 | 기술 참조 모델, 계층 구조, SW 제품명, 라이선스    |
| 3단계 | 하드웨어 및 네트워크 구성 파악  | 서버 사양, 수량, 이중화 여부, 네트워크 토폴로지     |

### 요구공학 프로세스
**도**출(Elicitation) → **분**석(Analysis) → **명**세(Specification) → **확**인(Validation, 검증)
1. **도출**
   - 이해관계자가 식별되고, 개발자와 고객 사이의 관계가 생성된다. 
   - 효율적인 의사소통이 중요
   - 종류: 인터뷰, 설문, 브레인스토밍, 워크숍, 유스케이스, 프로토타이핑
2. **분석**
   - 요구사항의 타당성 검토, 중복/상충 해결, 자료 흐름도(DFD) 활용
   - **기능적 요구사항**: "<u>시스템이 무엇(what)을 하는가?</u>" - 시스템 본연의 업무인지
   - **비기능적 요구사항**: "<u>시스템이 어떻게(how) 동작하는가?</u>" - 시스템의 성능이나 품질인지
   - **관점에 따른 분류**: 사용자(소프트웨어) 요구사항 / 시스템 요구사항
3. **명세**
   - 분석된 내용을 문서화
   - **정형 명세 기법**: 수학적 표현으로 요구사항을 정확하게 표현(검증 확실, 이해하기 어려움)
   - **비정형 명세 기법**: 자연어 기반으로 요구사항을 친숙하게 표현(검증 불분명, 이해하기 쉬움)
4. **확인**
   - 명세서가 고객의 의도와 맞는지 검토
   - **동료(Peer) 검토**: 동료들에게 내용을 직접 설명하며 결함 분석
   - **워크스루(Walk Through)**: 미리 명세서를 배포하여 사전 검토 후 짧은 회의를 통해 결함 분석
   - **인스펙션(Inspection)**: 명세서 작성자를 제외한 다른 사람들이 결함 분석
   - 그 외: 프로토타이핑, 모델 검증, 인수테스트
 
> 비기능적 요구사항: 가장 범위가 넓고 '어떻게(How)'나, '어떤 조건'이 섞인 문장을 선택

### 요구사항 분석 기법 - 구조적 분석
정형화된 절차에 따라 요구사항을 파악하고 도형 중심으로 표현한 도표
1. **자료흐름도(DFD)**
   - 기능에 의한 데이터의 흐름을 도형으로 표현한 도표
   - **프로세스(Process)**: 데이터 처리과정을 나타냄. <u>타원 ○</u>
   - **자료 흐름(Data Flow)**: 데이터 흐름 방향. <u>화살표 →</u>
   - **자료 저장소(Data Store)**: 데이터가 저장되는 곳. <u>상하 평행선 $=$</u>
   - **단말(Terminator)**: 데이터 입출력 주체. <u>사각형 □</u>
2. **자료 사전(DD)**
   - 자료 흐름도에 사용된 데이터의 이름과 속성을 표기한 자료(메타 데이터)이다.
   - **정의**: `=` 자료의 명명
   - **연결**: `+` 서로 다른 두 데이터를 연결
   - **선택**: `[ | ]` 복수의 데이터 중 선택
   - **반복**: `{ }` 반복되는 데이터
   - **생략**: `( )` 생략 가능 데이터
   - **주석**: `* *` 데이터를 설명하는 주석
3. **소단위 명세서(Mini-Spec)**: DFD의 최하위 프로세스의 처리 절차를 상세히 기술한 문서

### 자료 흐름도 작성 지침
- 단위 프로세스를 거친 데이터 흐름에는 새로운 이름 부여
- 데이터 출력을 위해서는 반드시 입력 필수
- 해당 프로세스와 하위 자료 흐름도의 데이터 흐름 일치
- 최하위 프로세스는 소단위 명세서를 가짐

### 객체지향 분석 방법론
1. **럼바우(Rumbaugh)**
   - 소프트웨어의 구성 요소를 다양한 그래픽 표기법을 이용하여 모델링하는 기법
   - `객제 모델링 → 동적 모델링 → 기능 모델링`
   - **객체(Object) 모델링**: 정보 모델링. 시스템에서 요구되는 객체를 찾고 관계를 정의 (<u>객체 다이어그램</u> 사용)
   - **동적(Dynamic) 모델링**: <u>상태 다이어그램</u>을 사용하여 객체들 간의 제어 흐름, 상태 변화를 표현
   - **기능(Functional) 모델링**: <u>자료흐름도(DFD)와 유스케이스</u>를 이용하여 다수의 프로세스 간 데이터 흐름을 표현
2. **부치(Booch)**: 미시적(Micro) 분석과 거시적(Macro) 분석을 모두 사용하는 방법론
3. **제이콥슨(Jacobson)**: 유스케이스를 활용하여 분석하는 방법
4. **Coad-Yourond**: E-R 다이어그램을 사용하여 객체의 행위를 모델링
5. **Wirfs-Brock**: 분석과 설계의 구분이 없고, 고객의 요구사항을 분석하여 강조

---

## 4) 소프트웨어 설계
### 소프트웨어 설계 모델
데이터 설계 → 아키텍쳐 설계 → 인터페이스 설계 → 절차 설계
- **데이터**: 요구사항 분석을 통해 식별된 정보를 자료 구조로 변환
- **아키텍처**: 소프트웨어를 구성하는 요소들의 관계 및 프로그램 구조
- **인터페이스**: 소프트웨어가 시스템 및 사용자와 상호작용하는 방식이나 구성
- **절차**: 각 모듈이 수행할 기능들을 절차적으로 구성

### 소프트웨어 설계 원리
1. **분할과 정복**: 여러 개의 작은 서브시스템으로 나눠서 각각을 완성
2. **모듈화(Modularity)**: 시스템 기능을 모듈 단위로 분류하여 성능/재사용성 향상
3. **추상화(Abstraction)**
   - 불필요한 부분은 생략하고 필요한 부분만 강조해 모델화
   - 문제의 포괄적인 개념을 설계 후 차례로 세분화하여 구체화 진행
   - **과정 추상화**: 기능의 전반적인 흐름만 파악 가능하게 설계
   - **데이터 추상화**: 데이터의 구조를 표현
   - **제어 추상화**: 이벤트 발생에 대한 대표 가능한 표현으로 작성
4. **단계적 분해(Stepwise refinement)**: 하향식 설계 전략으로, 추상화 수준이 높은 문장을 단계별로 구체화하는 기법(점진적으로 구체화). 세부 내역은 가능한 뒤로 미루어 진행
5. **정보 은닉(Information Hiding)**: 모듈 내부에 포함된 절차나 자료 정보를 숨겨서 다른 모듈의 접근이나 변경을 방지. 각 모듈을 독립적으로 수행할 수 있게 하며, 수정 시 파급 효과를 최소화

### 모듈화
프로그램이 효율적으로 관리될 수 있도록 시스템을 분해하고 추상화하는 기법
- **모듈의 크기 ↑**: 모듈의 개수 ↓ 통합 비용 ↓ (그러나 모듈 당 개발 비용 ↑)
- **모듈의 크기 ↓**: 모듈의 개수 ↑ 통합 비용 ↑
- 모듈은 공유도와 응집도가 높아야 하며, 제어도와 결합도가 낮아야 한다
- 공통 모듈 명세 원칙: 정확성(Correctness), 명확성(Clarity), 완전성(Completeness), 일관성(Consistency), 추적성(Traceability)

### 응집도(Cohesion)
모듈 내부의 요소들의 관계가 얼마나 밀접한지를 나타내는 정도
1. **기능적(Functional) 응집도**: 하나의 단일 기능을 수행하기 위해 구성
2. **순차적(Sequential) 응집도**: 하나의 요소 출력 데이터가 다음 요소의 입력 데이터로 사용됨 (파이프)
3. **교환적(Communication, 통신적) 응집도**: 동일합 입/출력 자료를 사용하여 서로 다른 기능을 수행
4. **절차적(Procedural) 응집도**: 하나의 문제를 해결하기 위해 여러 모듈들이 순차적으로 수행
5. **시간적(Temporal) 응집도**: 각 기능들의 연관성은 없지만 특정 시기에 함께 수행
6. **논리적(Logical) 응집도**: 유사한 성격의 기능들이 논리적으로 묶여 실행 시점에 선택됨
7. **우연적(Coincidental) 응집도**: 모듈 내부의 구성 요소들이 서로 아무런 관련이 없음

> 응집도가 강할수록 필요한 요소들로만 구성되므로 모듈의 독립성이 향상된다.
> - 높은 응집도 = 좋은 품질의 소프트웨어
> - 기능적 > 순차적 > 교환적(통신적) > 절차적 > 시간적 > 논리적 > 우연적

### 결합도(Coupling)
모듈과 모듈 간의 관련성이 얼마나 깊은지를 나타내는 정도
1. **자료(Data) 결합도**: 모듈 간의 인터페이스가 자료 요소로만 구성될 때의 결합도
2. **스탬프(Stamp) 결합도**: 배열이나 레코드 등의 자료 구조가 전달될 때의 결합도
3. **제어(Control) 결합도**: 값만 전달하는 것이 아니라 제어 요소를 함께 전달
4. **외부(External) 결합도**: 어떤 모듈에서 선언한 데이터를 외부의 다른 모듈에서 참조할 때의 결합도
5. **공유(Common) 결합도**: 공유되는 공통 데이터 영역을 여러 모듈이 사용할 때의 결합도
6. **내용(Content) 결합도**: 모듈이 다른 모듈의 내부 기능과 데이터를 직접적으로 사용

> 결합도가 약할수록 의존성이 약해지므로 모듈의 독립성이 향상된다.
> - 낮은 결합도 = 좋은 품질의 소프트웨어
> - 자료 < 스탬프 < 제어 < 외부 < 공유 < 내용

### 복잡도
1. **공유도(Fan-In)**: 자신을 호출(공유)하는 모듈의 수를 나타냄
   - 단일 실패지점이 발생할 수 있으므로 중점 관리 및 더 많은 테스트를 통한 검증이 필요
2. **제어도(Fan-Out)**: 자신이 호출(제어)하는 모듈의 수를 나타냄
   - 제어도가 높은 경우 불필요한 업무 로직을 단순화시킬 방법이 없는지 검토 필요

### NS 차트
논리적인 기술에 중점을 둔 도형을 이용한 표현 방법으로, 박스 다이어그램, Chapin Chart라고도 불린다.
- 연속, 선택 및 다중 선택, 반복 등의 제어 논리 구조를 표현
- GOTO나 화살표를 사용하지 않음
- 이해하기 쉽고, 코드 변환이 용이
- 읽기는 쉽지만 작성하기가 어려우며, 임의로 제어를 전이하는 것이 불가능

> - **순차(Sequence)** = **처리** → 위에서 아래로 차례대로 실행되는 상자 모양
> - **선택(Selection)** = **조건** → `if-then-else` 처럼 조건에 따라 갈라지는 모양
> - **반복(Iteration)** → `for`, `while`처럼 특정 구간을 되풀이하는 모양

### HIPO
시스템의 분석 및 설계나 문서화할 때 사용되는 기법. 하향식 소프트웨어 개발을 위한 문서화 도구
- 기능과 데이터의 관계를 계층 구조로 표현하여 한 눈에 이해하기 쉽도록 구성
- 종류: 가시적(Visual) 도표, 총체적(Overview) 도표, 세부적(Detail) 도표

### UML
소프트웨어 공학에서 사용되는 표준화된 범용 모델링언어. 사물, 관계, 다이어그램으로 구성되어 있다.
- 다이어그램은 여러 관점에서 시스템을 가시화한 뷰를 제공한다.
- 정적 모델링에서는 주로 구조적 다이어그램을 사용하고, 동적 모델링에서는 행위 다이어그램을 사용

#### 관계
1. **연관(Association)**: `──>` 둘 이상의 사물이 서로 관련되어 있음을 나타냄 
2. **집합(Aggregation)**: `──◇` 사물이 다른 사물에 포함되어 있는 관계. 전체와 부분은 서로 <u>독립적</u>이다 
3. **포함(Composition, 합성)**: `──◆` 사물이 다른 사물에 포함되어 있는 관계. 전체와 부분은 서로 <u>종속적</u>이다 
4. **일반화(Generalization)**: `──▷` 하나의 사물이 다른 사물에 대해 상위, 하위 관계를 가지는 것을 표현 (상속 관계) 
5. **의존(Dependency)**: `--->` 필요에 의해 짧은 시간 동안만 관계를 유지. 사물의 변화가 관계된 사물에 영향을 미침
6. **실체화(Realization)**: `---▷` 사물들의 공통적인 기능을 상위 사물로 그룹화하여 표현(추상화)

> 의존과 종속의 본질적인 뜻은 같지만, 연결의 밀도에 따라서 이를 분류해서 정의한다.
> - 의존: 느슨한 관계. 아주 잠깐 동안만 관계를 유지하는 것 (매개 변수는 메서드가 실행되는 동안에만 사용 되는 것이므로 의존)
> - 집합: 중간 정도의 관계. 전체가 사라져도 부분은 살아남음 
> - 포함(종속): 강한 결합. 생명주기를 같이함


#### 구조 다이어그램 (정적)
1. **클래스(Class)**
   - 클래스와 클래스가 가지는 속성, 관계를 표현
   - `-(private)`, `+(public)`, `#(protected)`, `~(default)`
2. **객체(Object)**: 클래스의 인스턴스를 객체 간의 관계로 표현
3. **컴포넌트(Component)**: 컴포넌트 간의 관계나 인터페이스를 표현 (구현 단계)
4. **배치(Deployment)**: 물리적 요소들의 위치를 표현 (구현 단계)
5. **복합체 구조(Composite Structure)**: 복합적인 구조를 가지는 컴포넌트, 클래스 등의 내부 구조를 표현
6. **패키지(Package)**: 모델 요소들을 그룹화한 패키지들의 관계를 표현

#### 행위 다이어그램 (동적)
1. **유스케이스(UseCase)**: 사용자의 요구를 분석하는 것으로 기능 모델링 작업에 사용
2. **순차(Sequence)**: 상호 작용하는 시스템이나 객체들이 주고받는 메시지를 표현
3. **커뮤니케이션(Communication)**: 객체들이 주고받는 메시지뿐만 아니라 객체들 간의 연관까지 표현
4. **상태(State)**: 클래스의 상태 변화 혹은 다른 객체와의 상호 작용에 따라 상태가 어떻게 변화하는지 표현(럼바우 동적 모델링에 사용)
5. **활동(Activity)**: 객체의 처리 로직이나 조건에 따른 처리의 흐름을 순서에 따라 표현
6. **상호작용 개요(Interaction Overview)**: 상호작용 다이어그램 간의 제어 흐름을 표현
7. **타이밍(Timing)**: 객체 상태 변화와 시간 제약을 명시적으로 표현

> 객체모델링 - 구조 다이어그램. 주로 객체와 클래스 다이어그램 사용 <br/>
> 동적 모델링, 기능 모델링 - 행위 다이어그램. 동적 모델링에는 상태 다이어그램, 기능 모델링에는 DFD와 상태 다이어그램

### 유스케이스의 구성요소
- **시스템(System)**: 개발하고자 하는 전체 프로그램의 범위. (사각형 박스)
- **액터(Actor)**: 시스템과 상호 작용하는 외부 엔티티 (사용자, 외부 시스템 등). (사람 모양)
  - **주액터**: 시스템을 통해 이득을 얻거나 특정 목표를 달성하려는 사용자
  - **부액터**: 주액터가 목적을 이룰 수 있도록 시스템에 서비스를 제공하는 외부 요소
- **유스케이스**: 시스템이 제공하는 개별적인 서비스나 기능을 의미. (타원)
- **관계**: 액터와 유스케이스, 또는 유스케이스 간의 상호작용. (실선, 점선 화살표)
  - 액터와 유스케이스 간의 상호작용은 실선으로 표현 (연관 관계-Association)
  - 반드시 실행되어야 하는 기능은 `<<include>>` (포함 관계)
  - 선택적으로 실행되는 기능은 `<<extend>>` (확장 관계)
  - 그룹화된 액터나 유스케이스 간의 상속 관계는 실선 화살표로 표현 (일반화 관계-Generalization)

### 순차 다이어그램의 구성 요소
- **생명선(LifeLine)**: 객체가 존재하는 시간의 흐름을 나타내는 수직 점선
- **실행(Activation)**: 객체가 현재 활성화되어 메시지를 처리 중임을 나타내는 수직 직사각형
- **메시지(Message)**: 객체 간에 주고받는 데이터나 신호. 화살표를 통해 상호작용을 표현

### 스테레오 타입
UML에서 표현하는 기본 기능 외에 추가 적인 기능을 표현하기 위해 사용
- 길러멧이라고 부르는 겹화살표(`<< >>`) 사이에 표현할 형태를 기술

### 코드(Code)
데이터를 사용 목적에 따라 그룹으로 분류하고 특정 자료의 선별을 용이하게 하기 위해 부여한 숫자, 문자 등으로 구성된 기호 체계
- **순차(Sequence) 코드**: 일정 기준에 따라 차례대로 일련번호를 부여
- **블록(Block) 코드**: 공통된 범위를 정하고 그 안에서 번호를 부여 
- **10진(Decimal) 코드**: 코드의 왼쪽에서 오른쪽으로 갈수록 세분화되는 그룹을 정의하여 10진수로 번호를 부여(도서 분류식 코드)
- **연상(Mnemonic) 코드**: 대상의 명칭이나 약자를 사용해 기억하기 쉽게 만듦
- **표의 숫자(Significant Digit) 코드**: 대상들의 물리적 수치를 코드에 직접 반영
- **합성(Combined) 코드**: 둘 이상의 코드를 함께 조합하여 부여

### 코드의 오류 발생 형태
1. **생략(Omission) 오류**: 한 자리를 누락(적지 않음)
2. **필사(Transcription) 오류**: 한 자리를 잘못 입력(오타)
3. **전위(Transposition) 오류**: 코드의 좌우 자리를 바꾸어 입력
4. **이중(Double) 오류**: 전위 오류가 둘 이상 발생
5. **추가(Addition) 오류**: 한 자리를 추가로 입력
6. **임의(Random) 오류**: 여러 오류가 둘 이상 발생

### 소프트웨어 아키텍처
- **계층 구조(Layered Pattern)**: 시스템을 서로 다른 계층으로 분할하여 상위 계층이 하위 계층의 서비스를 사용
- **클라이언트-서버**: 서비스를 요청하는 클라이언트와 제공하는 서버로 구성
- **파이프-필터**: 데이터 스트림을 생성하고 처리하며, 한 요소의 출력이 다름 요소의 입력이 되는 구조
- **MVC**
  - 애플리케이션을 데이터(Model), 사용자 인터페이스(View), 제어 로직(Controller)으로 분리하여 의존성을 제거
  - **Model**: 데이터와 비즈니스 로직을 담당. 상태가 변경되면 뷰나 컨트롤러에 알림 
  - **View**: 사용자에게 보여지는 화면(UI)를 담당. 데이터를 받아 화면에 출력하며 직접 저장하지는 않음
  - **Controller**: 모델과 뷰 사이의 상호작용을 제어. 입력을 받아 모델에 전달하고, 모델의 결과를 뷰에 반영
- **마스터-슬레이브**: 마스터 컴포넌트가 작업을 분할하여 슬레이브에게 배분, 슬레이브의 결과물을 취합
- **브로커**: 컴포넌트 간의 통신을 조정하는 중간자를 두어 원격 서비스 요청을 전달하고 응답받는 구조
- **Peer-to-Peer**: 컴포넌트가 서비스 요청자와 제공자 역할을 동시에 수행
- **이벤트 버스**: 소스가 특정 채널에 메시지를 발행하면, 이를 구독하는 리스너들이 감지하여 처리하는 발행/구독 방식
- **블랙보드**: 해결책이 명확하지 않은 문제를 풀기 위해 공유 데이터 공간에 여러 전문가 컴포넌트가 협력하여 답을 찾는 구조

### 미들웨어
OS와 응용 프로그램 또는 서버와 클라이언트 사이에서 다양한 서비스를 제공하는 소프트웨어
- **DBMS**: 데이터베이스와 연결
- **RPC(원격 프로시저 호출)**: 다른 컴퓨터에 있는 함수를 마치 내 컴퓨터에 있는 것처럼 호출
- **MOM(메시지 지향 미들웨어)**: 메시지 큐를 이용해 비동기 방식으로 데이터를 전달
- **TP-Monitor**: 온라인 트랜잭션 업무를 처리하고 감시 및 제어
- **ORB(객체 요청 브로커)**: 코바 표준 규격을 사용하여 객체 간의 통신을 도움
- **WAS(웹 애플리케이션 서버)**: 동적인 콘텐츠를 처리하며, 주로 DB 연동 작업에 사용된다. 

> 미들웨어는 데이터 교환의 일관성 유지를 위해 표준화된 인터페이스를 제공하므로 사용자가 정보 교환 방법 등을 확인할 필요가 없다.


---

## 5) 화면 설계
### UI
사용자와 컴퓨터 상호 간의 원활한 소통을 도와주는 연계 시스템
- **직관성(Intuitivity)**: 누구나 쉽게 이해하고 시용할 수 있어야함
- **유효성(Effectiveness)**: 사용자의 목적을 정확하게 달성해야 함
- **학습성(Learnability)**: 초보자도 금방 배울 수 있어야함
- **유연성(Flexibility)**: 사용자의 요구를 최대한 수용하고 오류를 최소화

### UI의 핵심 기능
- **피드백**: 사용자의 작업에 대해 시스템이 즉각적으로 응답을 주는 기능 
- **도움말**: 사용자가 기능을 모르거나 문제가 생겼을 때 해결 방법을 알려주는 기능
- **오류 예방 및 복구**: 사용자가 실수하지 않게 미리 막거나, 실수했을 때 되돌릴 수 있게 하는 기능

### UI의 종류
- **CLI**: 명령 문자열을 통해 시스템과 상호 작용
- **GUI**: 그래픽 요소를 통해 상호작용
- **NUI(Natual User Interface)**: 사용자의 말이나 행동으로 기기를 조작 (자연스러운 행동으로 )
- **VUI**: 음성으로 기기를 조작
- **OUI(Organic User Interface)**: 모든 사물과 사용자 주변 환경을 UI로 활용

### UI의 요소
- **텍스트 박스**: 서비스 이용에 필요한 정보를 입력
- **라디오(Radio) 버튼**: 다수의 나열된 항목 중 하나의 값을 선택
- **토글(Toggle) 버튼**: 하나의 버튼으로 두 상태를 번갈아가며 설정
- **목록 상자(List Box)**: 여러 항목이 나열되어 있는 상자(목록 내에서만 선택만 할 수 있음)
- **콤보(Combo) 박스**: 목록 상자 + 텍스트 박스(목록에 없는 값에 대해 직접 입력 가능)
- **체크(Check) 박스**: 다수의 나열된 항목 중 하나 이상의 값을 선택
- **명령(Command) 버튼**: 전송, 이동, 초기화 등의 지정된 명령을 수행

### UI 설계 도구 
- **와이어프레임**: 기획 초기에 제작. 레이아웃이나 UI 요소 등에 대한 뼈대를 설계
- **목업**: 실제 화면과 유사한 형태로 제작한 정적인 모델
- **프로토타입**: 실제 구현된 것처럼 테스트가 가능한 동적인 형태의 모형
- **스토리보드**: 디자이너와 개발자가 최종적으로 참고하는 작업 지침서
- **유스케이스**: 사용자 측면에서의 요구사항

### UX
사용자가 시스템을 이용하면서 느끼게되는 종합적인 경험

> UI vs UX
> - UI: 사용자와 시스템 간의 '접점' 혹은 '도구'
> - UX: 사용자가 느끼는 '총체적인 경험' (주관적이며 감정적이다.)

### 감성공학
인간의 특징이나 감성을 UI 설계에 최대한 반영시키는 기술

### HCI
인간과 시스템의 상호작용이 보다 편리하고 안전하게 이루어지도록 연구하는 학문

---

## 6) 인터페이스 설계
### 직접 연계 방식
중간 매개체 없이 송·수신 시스템이 직접 연결되는 방식으로 비용이 저렴하고 속도가 빠르지만, 시스템 변경 시 대응이 어려움
- **DB Link**: DB에서 제공하는 기능. 이름을 지정하여 원격 DB에 접속
- **DB Connection**: 수신 시스템의 WAS와 송신 시스템의 DB를 직접 연결
- **API**: 응용 프로그램에서 데이터를 주고받기 위한 인터페이스 함수를 이용하는 방식
- **Open API**: 누구나 사용할 수 있도록 공개된 인터페이스.
- **JDBC**: 자바 프로그램이 DB에 접속하고 SQL을 실행할 수 있게 해주는 표준 API

### 간접 연계 방식
중간에 연계 서버(미들웨어)를 두고 데이터를 주고받는 방식. 구조가 복잡하고 비용이 들지만, 보안과 통합 관리가 유리
- **EAI**: 기업 내 서로 다른 플랫폼 및 애플리케이션을 통합하여 데이터를 공유하게 해주는 솔루션
- **ESB**: 애플리케이션 간 통합을 위해 서비스 중심의 버스 형태를 사용하여 결합도를 낮춘 아키텍처
- **Socket**: 두 프로그램이 네트워크를 통해 서로 데이터를 주고받을 수 있도록 연결해 주는 통신 통로
- **Web Service**: 서로 다른 언어나 OS를 쓰는 컴퓨터들이 웹 표준 기술을 이용해 대화할 수 있게 해주는 연결 방식
  - **SOAP**: 이기종 시스템의 데이터, 서비스 호출을 위한 XML 기반의 통신 규약
  - **UDDI**: 간편한 웹 서비스 검색을 위한 XML 기반의 통합 레지스트리
  - **WSDL**: 웹 서비스를 기술하기 위한 XML 기반 표준 언어

### EAI
- **Point-to-Point**: 애플리케이션간 1:1로 직접 연결하는 방식
- **Hub & Spoke(EAI)**: 중앙에 허브를 두고 모든 시스템을 연결하는 중앙 집중 방식
- **Message Bus(ESB)**: 애플리케이션 사이에 미들웨어(버스)를 두어 데이터를 전송
- **Hybrid**: 그룹 내부는 Hub & Spoke, 그룹 간에는 Message Bus

### 데이터 표준
- **XML**: 태크를 사용하여 데이터의 구조를 정의하는 언어
- **JSON**: <속성, 값> 쌍으로 이루어진 경량 데이터 포맷. 자바스크립트 객체 문법을 따르며, XML 보다 가볍고 빠르다
- **YAML**: JSON에서 발전된 마크업 언어. 데이터 직렬화 양식으로 들여쓰기를 사용해 구조를 표현. 주로 설정 파일에 사용된다.

### AJAX(Asynchronous JavaScript And XML)
비동기식 자바스크립트와 XML의 약자로, 브라우저가 서버와 데이터를 주고받을 때 전체 페이지를 새로고침하지 않고 필요한 부분만 동적으로 업데이트하는 기술

### 인터페이스 구현 검증 도구
- **xUnit**: 다양한 언어를 지원하는 단위 테스트 프레임워크
- **STAF**: 분산 환경을 지원하는 테스트 프레임워크
- **FitNesse**: 웹 기반 테스트 프레임워크. 테스트 케이스를 표 형태로 작성
- **NTAF**: 네이버에서 개발. FitNesse + STAF
- **watir**: Ruby 기반의 웹 애플리케이션 테스트 프레임워크

---

## 7) 객체지향 설계
### 객체지향 기술의 구성 요소
- **클래스**: 객체의 타입을 정의하고 구현하는 틀
- **객체**: 클래스에 의해 구현된 각각의 대상들을 총칭하는 것
- **인스턴스**: 특정 클래스에 의해 구현된 객체
- **메시지**: 객체 간 통신을 위해 주고받는 인터페이스
- **메서드**: 요청 메시지에 의해 객체가 수행되어야 할 연산을 정의한 것

### 객체지향 기술
- **캡슐화(Encapsulation)**: 데이터와 이를 처리하는 메서드를 하나의 단위로 묶는 것
- **정보 은닉(Information Hiding)**: 캡슐화된 데이터에 의해 외부의 직접적인 접근을 제한하는 기법
- **추상화(Abstraction)**: 객체의 핵심적인 공통 속성과 기능만을 추출하는 것
- **상속(Inheritance)**: 정의된 상위 클래스의 모든 특성을 하위 클래스가 물려받는 것
- **다형성(Polymorphism)**: 하나의 메시지나 이름이 상황에 따라 다양한 형태의 기능으로 동작하는 것
  - 오버라이딩: 상속받은 메서드를 자식이 새롭게 정의 (메서드의 구현부가 완전히 일치해야함)
  - 오버로딩: 메서드의 이름은 동일하나 매개변수의 개수와 타입이 다름 

> 캡슐화: 묶는다, 결합, 경계를 만든다 <br/>
> 정보 은닉: 접근 제한, 은폐, private

### 객체지향 설계 원칙(SOLID)
- **SRP(Single Responsibility Principle, 단일 책임 원칙)**: 하나의 클래스는 하나의 책임만 가져야 한다.
- **OCP (Open-Closed Principle, 개방-폐쇄 원칙)**: 확장에는 열려(Open) 있어야 하고, 수정에는 닫혀(Close) 있어야 한다.
- **LSP (Liskov Substitution Principle, 리스코프 치환 원칙)**: 자식 클래스는 언제나 자신의 부모 클래스를 대체할 수 있어야 한다.
- **ISP (Interface Segregation Principle, 인터페이스 분리 원칙)**: 사용하지 않는 인터페이스는 구현하지 않아야 한다. (포괄적인 인터페이스 보다. 다수의 구체적인 인터페이스를 구상)
- **DIP (Dependency Inversion Principle, 의존 역전 원칙)**: 구체적인 클래스보다 추상황에 의존. 하위 클래스의 변경 사항이 상위 클래스에 영향을 주지 않아야 함.

### GoF
소프트웨어 설계에서 공통으로 발생하는 문제들에 대한 재사용 가능한 해결책을 23개의 디자인 패턴으로 정리한 것
- 반복적인 문제들을 해결하기 위한 설계 패턴을 일반화한 것
- 구성요소: 패턴이름, 문제, 해결책(Solution), 결과(Consequences)
- 종류: 생성 패턴(Creational), 구조 패턴(Structural), 행위 패턴(Behavioral)

#### 생성 패턴
객체의 생성 과정에 관여하며, 객체의 생성과 참조 과정을 캡슐화하여 시스템의 유연성을 높임
1. **추상 팩토리(Abstract Factory)**
   - 관련이 있는 서브 클래스를 묶어서 팩토리 클래스를 만들고, 조건에 따라 객체를 생성
   - 구체적인 클래스에 의존 x. 서로 연관되거나 의존적인 객체들의 조합을 생성하기 위한 인터페이스를 제공
2. **빌더(Builder)**
   - 객체 생성에 많은 인수가 필요한 복잡한 객체를 단계적으로 생성하는 패턴
   - 동일한 생성 절차에서 서로 다른 결과를 만들 수 있다.
3. **팩토리 메서드(Factory Method)**
   - 상위 클래스에서는 객체를 생성하기 위한 인터페이스를 정의하고 하위 클래스는 어떤 클래스의 인스턴스를 생성할 것인지를 결정
   - 객체 생성을 자식 클래스에서 결정하도록 상속을 통해 캡슐화
4. **프로토타입(Prototype)**
   - 동일한 타입의 객체를 생성해야 할 때 필요한 비용을 줄이기 위한 패턴
   - 원형이 되는 인스턴스를 사용하여 객체를 복사하여 생성
5. **싱글톤(Singleton)**
   - 클래스가 오직 하나의 인스턴스만을 가지도록 한다.
   - 클래스의 인스턴스가 단 하나만 생성되도록 보장하고, 어디서든 그 인스턴스에 접근할 수 있도록 한다

#### 구조 패턴
클래스나 객체를 조합하여 더 큰 구조를 만드는 패턴
1. **어댑터(Adapter)**
   - 서로 다른 인터페이스를 가진 클래스들을 함께 사용할 수 있도록 하는 패턴
   - 이들을 연결하여 호환성을 맞춤
2. **브리지(Bridge)**
   - 기능부와 구현부로 분리한 뒤, 두 클래스를 연결
   - 이를 통해 서로 독립적으로 확장할 수 있게 된다. (결합도가 낮아짐)
3. **컴포지트(Composite)**
   - 객체들의 관계를 트리 구조로 구성하여 단일 객체와 복합 객체를 동일하게 다루도록하는 패턴
   - 사용자는 객체를 구분하지 않고 일관된 방식으로 다룰 수 있다
4. **데코레이터(Decorator)**
   - 클래스 변경 없이 주어진 상황에 따라 기능을 추가하는 패턴
   - 상속 대신 객체 결합을 통해 동적으로 기능을 확장
5. **퍼사드(Facade)**
   - 복잡한 서브 시스템을 간편하게 사용할 수 있도록 단순화된 인터페이스를 제공
   - 사용자가 내부의 구조를 몰라도 창구(Facade)를 통해 이용할 수 있음
6. **플라이웨이트(Flyweight)**
   - 메모리 사용량을 최소화하기 위해 객체들 간 데이터 공유를 극대화하는 패턴
   - 메모리 공유를 통해 낭비를 줄임
7. **프록시(Proxy)**: 특정 객체로의 접근을 해당 객체의 대리자를 통해 진행하는 패턴

#### 행위 패턴
클래스나 객 체들 사이의 상호작용이나 책임 분담을 정의
1. **책임 연쇄(Chain of Responsibility)**
   - 문제의 해결을 위한 일련의 처리 객체가 순서대로 문제를 해결하는 패턴
   - 고리처럼 연결되어 처리 가능한 객체를 만날 때까지 요청을 전달함
   - 요청자와 처리자를 분리해 결합도를 낮춤
2. **커맨드(Command)**
   - 요청을 객체의 형태로 캡슐화하여 나중에 이용할 수 있도록 요청에 필요한 정보를 저장
   - 실행 취소 기능을 구현할 때 주로 사용
3. **인터프리터(Interpreter)**: 언어의 문법을 평가(해석)하는 방법을 규정
4. **반복자(Iterator)**
   - 내부 구현을 노출시키지 않고 집약된 객체에 접근하고 싶은 경우에 적용
   - 컬렉션에 있는 모든 요소에 순차적으로 접근하는 방법을 제공
5. **중재자(Mediator)**: 객체들 간의 통신이 직접 이루어지지 않고 중재자를 통해 진행되어 결합도를 감소
6. **메멘토(Memento)**
   - 롤백을 통해 객체의 상태를 이전 상태로 되돌릴 수 있는 기능을 제공
   - 객체의 캡슐화를 유지하면서 상태를 저장
7. **옵저버(Observer)**
   - 객체의 상태 변화가 있을 때마다 등록된 옵저버에게 통지
   - 그 객체를 의존하는 다른 객체들에게 자동으로 통지하고 갱신하는 것
8. **상태(State)**: 객체의 내부 상태에 따라 다른 기능을 수행하는 메서드를 구현하는 패턴
9. **전략(Strategy)**
   - 다양한 알고리즘이 적용될 수 있는 경우에 알고리즘을 별도로 분리(캡슐화)
   - 클라이언트는 영향을 받지 않고 실행 중에 알고리즘을 선택할 수 있음
10. **템플릿 메서드(Template Methode)**: 상위 클래스에서는 알고리즘의 뼈대를 정의하고 구체적인 단계를 하위 클래스에서 정의하는 패턴
11. **방문자(Visitor)**
    - 알고리즘을 자료 구조에서 분리하여 클래스를 수정하지 않고도 새로운 알고리즘을 추가할 수 있는 패턴
    - 데이터 구조에서 처리 기능을 분리하여 별도의 클래스를 만듦

> 전략 vs 방문자
> - 전략: 행위(알고리즘)를 캡슐화하여 상호 교환 가능하게 만드는 것
> - 방문자: 객체 구조를 변경하지 않고 새로운 연산을 추가하는 것

--- 

## 8) 테스트
### 소프트웨어 테스트의 원리
1. **결함 집중(Defect Clustering)**: 전체 결함의 대부분은 특정 모듈에 집중되어 있다.
   - **낚시의 법칙**: 낚시 포인트처럼 특정 위치에서 많은 결함 발생
   - **파레토 법칙(Pareto Principle)**: 결함의 80%의는 20%의 기능에서 집중적으로 발생
2. **살충제 패러독스(Pesticide Paradox)**: 동일한 테스트 케이스로 반복 실행하면 새로운 결함을 발견할 수 없다
3. **오류-부재의 궤변(absence of Errors Fallacy)**: 결함이 없더라도 요구 사항을 만족하지 못한다면 품질 보증 불가능

### 소프트웨어 결함
- **오류(Error)**: 결함의 원인이 되는 것. 사람에 의해 생성되는 실수
- **결함(Defect)** / **결점(Fault)** / **버그(Bug)**: 오류가 원인이 되어 제품에 포함되는 완전하지 못한 부분
- **실패(Failure)** / **문제(Problem)**: 결함에 의해 의도하지 않은 결과가 발생

### 테스트와 디버깅
- **테스트**: 제품에 대한 검증과 확인을 수행하는 것
  - **검증(Verification)**: 명세서대로 만들었는지 개발과정에 대한 테스트 (개발자 입장)
  - **확인(Validation)**: 사용자가 원하는대로 만들었는지 개발 결과에 대한 테스트 (사용자 입장)
- **디버깅**: 프로그램의 오류를 찾고, 수정하는 것

### 소프트웨어 테스트 유형
- **정적 테스트**
  - 프로그램 실행 없이 소스코드의 구조만 분석
  - 종류: 인스펙션, 동료 검토, 워크스루
- **동적 테스트**
  - 프로그램의 실행 화면을 보면서 테스트를 수행
  - 종류: 화이트박스, 블랙박스
- **목적 기반 테스트**
  - 소프트웨어의 특정 특성을 파악하기 위한 목적으로 테스트를 수행
  - 종류: 회복, 안전, 강도, 성능, 구조, 회귀, 병행
- **설계 기반 테스트**
  - 테스트의 진행이 되는 자료에 따라 구분
  - 종류: 명세 기반, 구조 기반, 경험 기반

### 화이트박스 테스트
프로그램의 내부 로직을 중심으로 테스트를 진행
- **기초 경로 검사(Base Path Testing)**: 대표적인 화이트박스 기법으로, 설계의 논리적 복잡도를 측정하여 수행 가능한 모든 경로를 테스트 케이스로 설계 
- **제어 구조 검사(Control Structure Testing)**: 프로그램 내부의 선택, 반복 등의 제어 구조를 집중적으로 검사
  - **조건(Condition) 검사**: 논리적 조건을 테스트 
  - **루프(Loop) 검사**: 반복문의 구조를 테스트
  - **데이터 흐름 검사(Data Flow Testing)**: 변수의 정의와 사용 과정을 추적

> 순환 복잡도의 계산 결과는 기초 경로 검사에서 설계해야 할 최소한의 테스트 케이스 수 <br/>
> 단위 테스트에서 진행함.

### 블랙박스 테스트
프로그램의 기능을 중심으로 테스트를 진행
- **동치(동등) 분할 검사(Equivalence Partitioning)**: 입력 자료에 초점을 맞춰 테스트 케이스를 만들고 검사
- **경계값 분석 (Boundary Value Analysis)**: 동치 분할 기법을 보완. 입력 조건의 중간값보다 경계값에서 오류가 발생될 확률이 높다는 점을 이용하여 입력 조건의 경계값을 테스트
- **원인-결과 그래프 검사(Cause-Effect Graphing)**: 입력 데이터 간의 관계와 출력에 미치는 영향을 그래프로 분석하여 테스트 케이스를 선정
- **오류 예측 검사(Error Guessing)**: 테스터의 경험과 감각으로 과거의 사례나 예상되는 오류를 찾아내는 테스트
- **비교 검사(Comparison Test)**: 여러 버전의 프로그램에 동일한 데이터를 입력하여 결과가 일치하는지 확인
- **상태 전이 테스트(State Transition Testing)**: 객체의 상태 변화를 모델링하여 상태가 전이되는 과정을 테스트

### 테스트 오라클
테스트의 결과가 참인지 거짓인지를 판단하기 위해서 사전에 정의된 참 값을 입력하여 비교하는 기법 및 활동
- **참(True) 오라클**: 모든 입력값에 대해 기대하는 결과를 생성
- **샘플링(Sampling) 오라클**: 특정 몇개의 입력값에 대해서만 기대하는 결과를 제공
- **추정(Heuristic) 오라클**: 특정 입력값의 결과는 제공하고, 나머지는 추정으로 처리
- **일관성 검사(Consistent) 오라클**: 애플리케이션의 변경 전후 결과값이 동일한지 확인

### V 모델
개발 단계별로 검증하고 수행해야 하는 테스트를 시각화한 모델
![v모델](vmodel.png)

- **단위(Unit) 테스트**: 최소 단위인 모듈을 중심으로 테스트
- **통합(Integration) 테스트**: 단위 테스트가 끝난 모듈을 결합해 모듈 간 인터페이스 오류를 확인
- **시스템(System) 테스트**: 실제 환경과 유사하게 맞춰 테스트
- **인수(Acceptance) 테스트**: 사용자 요구사항 충족 여부를 테스트

### 단위 테스트 도구
- **xUnit**: JUnit, CppUnit, NUnit, HttpUnit
- **Mock**: Mockito, jMock, PowerMock

### 통합 테스트 방식
- **비점진적 방식(Big-Bang)**: 모든 모듈을 한꺼번에 결합하여 테스트. 단기간에 가능하지만, 오류 발생 시 원인을 찾기가 어렵다
- **점진적 통합: 모듈을 단계별로 결합**
  - **하향식(Top-Down)**: 제어 모듈(상위)에서 하위 모듈로 통합하며, 깊이 우선 또는 너비 우선 방식으로 진행. 미완성 하위 모듈 대신 <u>스텁(Stub)</u>을 사용
  - **상향식(Bottom-Up)**: 아래에서 위로 통합. 상위 모듈 역할을 하는 <u>드라이버(Driver)</u>가 필요
- **회귀(Regression) 테스트**: 통합 테스트가 완료된 후에 변경점이 있으면, 오류가 없는지 이전과 같은 케이스로 테스트 수행


### 인수 테스트 방식
- **알파 테스트**: 개발자의 장소에서 진행
- **베타 테스트**: 제한되지 않은 환경에서 테스트

### 테스트 하네스
테스트를 지원하기 위한 코드와 데이터들의 총칭
- **테스트 드라이버(Driver)**: 상위 모듈 없이 하위 모듈을 테스트할 때, 데이터 입출력을 제어하는 가장 상위 모듈
- **테스트 스텁(Stub)**: 하위 모듈이 아직 개발되지 않았을 때, 일시적으로 호출에 응답하는 가상의 하위 모듈
- **테스트 슈트(Suite)**: 테스트 대상에 대해 수행할 테스트 케이스들의 집합
- **테스트 케이스(Case)**: 특정 요구사항을 만족하기 위해 설계된 입력값, 실행 조건, 기대 결과의 명세서
- **테스트 스크립트(Script)**: 테스트 케이스의 실행 순서와 절차를 기록한 파일(자동화)
- **목업(MockUp)**: 객체의 행위를 검증하기 위해 사용되는 가짜 객체

### 테스트 커버리지
테스트 코드의 어느 정도를 검증했는지를 측정하는 지표
- 결함을 놓치지 않도록 테스트 범위를 정의하고 향상시키기 위한 도구
- 여러 커버리지 기준으로 테스트의 완성도를 분석할 수 있다
- 기능 기반, 라인, 코드 커버리지가 있다

### 코드 커버리지
화이트박스 테스트의 대표적인 기법으로 소스 코드의 구문, 조건, 분기 등이 테스트 과정에서 얼마나 실행되었는지를 수치로 나타내는 지표
- **구문(Statement) 커버리지**
  - 모든 코드를 한 번 이상 실행했는지 확인
  - 코드의 각 문장을 최소 1번실행
  - 가장 기본적이고, 조건 만족 여부는 무관
- **결정(Decision) 커버리지**
  - 조건 전체 결과가 모두 발생했는지 확인
  - 분기점의 전체 흐름을 점검
  - 각 조건문의 전체 결과가 적어도 한 번은 실행되도록 구성
- **조건(Condition) 커버리지**
  - 모든 조건식을 참/거짓으로 테스트
  - 조합은 신경쓰지 않고, 개별 조건만 검증
- **조건/결정 커버리지**: 결정 커버리지와 조건 커버리지를 동시에 만족
- **변경 조건/결정 커버리지**: 조건 때문에 결정 포인트가 바뀌는지
- **다중 조건 커버리지**: 모든 조건의 조합을 테스트($2^n$개). 조건들 간의 모든 경우의 수 검증

> 조건과 결정의 구분 `if(a > 0 && b > 0)`
> - 조건: `a > 0`, `b > 0` 분기문에서의 개별 조건에 대한 결과값
> - 결정: 해당 분기문에서 전체적인 참/거짓 여부 

----

## 9) 유지 보수
### 소프트웨어 3R
재공학(**R**e-Engineering), 역공학(**R**everse Engineering), 재사용(**R**euse)
- **재공학**: 기존의 시스템을 이용하여 보다 나은 시스템을 구축하는 방법
  - **분석(Analysis)**: 기존 시스템의 명세를 확인하고 재공학 대상을 선정
  - **재구성(Restructuring)**: 소프트웨어의 외적 기능은 바꾸지 않고 코드 구조만 개선
  - **역공학(Reverse Engineering)**: 코드로부터 설계 정보를 추출
  - **이식(Migration)**: 다른 하드웨어나 운영체제 환경으로 시스템을 옮김
- **재사용**
  - **함수와 객체 재사용**: 클래스나 메서드 단위의 소스코드를 재사용
  - **컴포넌트 재사용**: 컴포넌트가 자체 수정 x. 인터페이스를 통해 재사용
  - **애플리케이션 재사용**: 공통 업무 기능을 제공하는 애플리케이션을 재사용

### DRM
디지털 콘텐츠의 저작권을 보호하고 관리하는 기술
- **콘텐츠 제공자(Provider)**: 콘텐츠를 제공하는 저작권자
- **콘텐츠 분배자(Distributor)**: 암호화된 콘텐츠를 유통하는 곳이나 사람
- **클리어링 하우스(Clearing House)**: 저작권료 결제 및 라이선스 발급을 관리하는 핵심 기관
- **DRM 컨트롤러**: 배포된 콘텐츠의 이용 권한을 통제
- **패키저(Packager)**: 콘텐츠를 암호화하고 메타 데이터와 함께 패키징
- **기술 요소**: `암호화, 키 관리, 암호화 파일 생성, 식별 기술, 저작권 표현, 정책 관리, 크랙 방지, 인증`

### 버전 관리 시스템
- **공유 폴더(Local)**: 로컬 PC의 공유 폴더에 복사본을 만들어 관리하는 원시적인 방법. 
  - **SCCS**: 최초의 버전 관리 시스템 (UNIX 계열). 파일 전체를 저장하지 않고 변경 이력만 관리
  - **RCS**: 한 번에 한 사람만 수정 가능 (Locking 방식).
- **클라이언트/서버 방식**: 중앙 서버에 소스를 두고, 필요한 파일만 자신의 PC로 가져와서 수정 후 다시 서버로 보냄. 
  - **CVS**: 서버에 소스를 두고 여러 명이 동시 수정 가능. 충돌 발생 시 수동 해결 필요
  - **SVN(Subversion)**: CVS의 단점을 보완. 커밋 중 오류 발생 시 전체 취소 기능 제공(원시적 커밋)
- **분산 저장소 방식**: 로컬 PC에도 전체 저장소 복사본이 존재. 서버 연결 없이도 로컬에서 커밋 가능
  - **Git**: 리눅스 커널 개발을 위해 만든 분산형 도구.
  - **Bitkeeper**: Git 이전에 리눅스 커널 관리에서 사용되었던 분산 관리 도구

### 형상 관리 도구의 기능
- **check-out**: 저장소로부터 원하는 버전의 소프트웨어 형상의 사본을 가져오는 것
- **check-in**: 개발자가 수정한 소스코드를 저장소에 업로드
- **commit**: 저장소 업로드가 성공적으로 완료되었을 때, 반영을 최종 승인하는 기능
- **update**: 저장소와 컴퓨터 형상을 동기화하는 기능 (소스코드 수정 전에 반드시 수행)
- **import**: 비어 있는 저장소에 처음 소스를 업로드
- **export**: 버전 관리 파일을 뺀 순수 소스코드 파일만 받아오는 기능

---

## 10) 품질관리 및 표준
### ISO/IEC 12207
소프트웨어 생명주기 프로세스
- **기본 프로세스**: 획득, 공급, 개발, 운영, 유지보수
- **지원 프로세스**: 품질 보증, 검증, 확인, 활동 검토, 문제 해결
- **조직 프로세스**: 관리, 인프라, 훈련, 개선

### ISO/IEC 12119
패키지 소프트웨어의 제품 품질 요구사항 및 테스트를 위한 국제 표준

### ISO/IEC 29119
소프트웨어 테스트를 위한 국제표준 

### ISO/IEC 9126(25010)
소프트웨어 품질 및 평가에 관한 표준으로, 2011년에 호환성과 보안성을 강화하여 25010으로 개정됨
- **기능성(Functionality)**: 사용자의 요구사항을 정확하게 만족하는 기능을 제공하는지 
- **신뢰성(Reliability)**: 일정한 시간 동안 오류 없이 기능을 수행하고 고장을 견딜 수 있는가
- **사용성(Usability)**: 사용자가 서비스를 쉽게 이해하고 배우며 편리하게 사용할 수 있는가
- **효율성(Efficiency)**: 정해진 시간 내에 자원을 얼마나 최소로 사용하며 빠르게 처리하는가
- **유지보수성(Maintainability)**: 환경 변화나 오류 수정 시 소프트웨어를 얼마나 쉽게 변경할 수 있는가
- **이식성(Portability)**: 소프트웨어를 다른 환경으로 얼마나 쉽게 옮길 수 있는가

### CMM
소프트웨어 개발 업체들의 업무 능력 평가 기준을 세우기 위한 평가 능력 성숙도 모델
- 초기 → 반복 → 정의 → 관리 → 최적화

| 레벨  | 성숙도 단계          | 설명                                     |
| --- | --------------- | -------------------------------------- |
| 1   | 초기(Initial)     | 개발 관리 프로세스가 없으며, 개인의 역량에 따라 성공 여부가 결정됨 |
| 2   | 반복(Repeatable)  | 성공한 프로젝트를 유사한 프로젝트에 다시 적용 (경험을 통한 관리)  |
| 3   | 정의(Defined)     | 조직 차원의 표준 프로세스가 정의되어 있음(경험 공유)         |
| 4   | 관리(Managed)     | 프로세스 성과를 정량적으로 측정하고 관리                 |
| 5   | 최적화(Optimizing) | 지속적인 품질 개선이 진행 (위험 예측 및 도구 활용)         |

### CMMI
CMM을 통합하여 발전시킨 조직 전체의 역량 평가 모델
- 초기 → 관리 → 정의 → 정략적 관리 → 최적화
- 2단계와 4단계의 명칭이 바뀌었음 

> CMM vs CMMI
> - 2단계(반복 → 관리): CMM의 '반복'은 성공 사례를 다시 쓴다는 의미이며, CMMI로 발전되면서 이를 시스템적으로 '관리'한다는 포괄적인 의미로 확장되었음
> - 4단계(관리 → 정량적 관리) : CMM의 '관리'는 정량적 관리를 의미했지만, CMMI의 2단계 이름이 '관리'가 되면서 4단계를 이를 더 명확하게 구분하기 위해 '정량적'이라는 수식어를 붙임

### SPICE(ISO/IEC 15504)
소프트웨어 품질 및 생산성 향상을 위한 소프트웨어 프로세스를 평가하는 국제 표준

| 레벨  | 명칭                  | 프로세스 달성 수준                           |
| --- | ------------------- | ------------------------------------ |
| 0   | 불완전 (Incomplete)    | 프로세스가 구현되지 않거나 프로세스 목적을 달성하지 못함      |
| 1   | 수행 (Performed)      | 해당 프로세스의 목적은 달성하지만 계획되거나 추적되지 않음     |
| 2   | 관리 (Managed)        | 수행이 계획되고 관리되어 작업 산출물이 규정된 표준과 요구에 부합 |
| 3   | 확립 (Established)    | 표준 프로세스를 사용하여 계획되고 관리                |
| 4   | 예측 가능 (Predictable) | 표준 프로세스 능력에 대하여 정량적인 이해와 성능이 예측 가능   |
| 5   | 최적 (Optimizing)     | 정의된 프로세스와 표준 프로세스가 지속적으로 개선          |

### 소스코드 품질 분석 도구
- **정적 분석 도구**: `pmd, cppchek, SonarQube, checkstyle`
- **동적 분석 도구**: `Avalanch, Valgrind`
- **인스펙션**: 사람이 직접 읽고 검토하여 찾아내는 형식적인 정적 분석 기법(명세서를 작성한 사람이 아닌 다른 사람이 읽음)

### 소프트웨어 품질 목표 항목
- **정확성(Correctness)**: 요구사항을 충족
- **신뢰성(Reliability)**: 오류가 없어야 함
- **효율성(Efficiency)**: 최소한의 자원으로 수행
- **무결성(Integrity)**: 데이터의 수정을 제어
- **유지보수 용이성(Maintainability)**
- **사용 용이성(Usability)**
- **검사 용이성(Testability)**
- **이식성(Portability)**: 다양한 환경에서도 운용될 수 있는 능력
- **상호 운용성(Interoperability)**: 다른 소프트웨어와 데이터를 주고받을 수 있는 능력
- **유연성(Flexibility)**: 쉽게 수정할 수 있어야 함
- **재사용성(Reusability)**: 다른 목적으로도 사용할 수 있어야함

---

[^1]: 일에 필요한 총 노동량.
[^2]: 지불할 총 비용
[^3]: 프로그램을 개발하는 총 기간
[^4]: 얼마나 효율적인지
