---
layout: post
title: 6.프로그래밍 언어
date: 2026-02-25
categories: [자격증, 정보처리기사]
sitemap: false
math: true
media_subpath: /assets/img/posts/
comments: false
---

## 공통
### 변수 선언 규칙
1. 변수명의 첫 글자는 연문자 또는 언더바(`_`)만 사용
2. 예약어로 변수명을 지을 수 없다.

### 자료형 크기

| 자료형    | C언어 | Java |
|--------|-----|------|
| byte   | 없음  | 1    |
| short  | 2   | 2    |
| int    | 4   | 4    |
| long   | 4   | 8    |
| char   | 1   | 2    |
| float  | 4   | 4    |
| double | 8   | 8    |

### 비트 논리 연산자

| 연산자  | 계산식    | 설명                       |
|------|--------|--------------------------|
| &    | a & b  | and 연산 (둘 다 1일 때 1)      |
| \|   | a \| b | or 연산 (둘 중 하나가 1이면 1)    |
| ^    | a ^ b  | xor 연산 (두 값이 서로 다를 때만 1) |
| ~    | ~a     | not 연산 (1을 0으로, 0을 1로)   |
| `>>` | a >> b | a의 비트를 우측으로 b만큼 이동       |
| `<<` | a << b | a의 비트를 좌측으로 b만큼 이동       |

#### 시프트 연산 계산
- `>> (오른쪽 시프트)`: $n ÷ 2^x$
- `<< (왼쪽 시프트)`: $n × 2^x$

### 연산자 우선순위
- 일반적인 산술 및 비교 연산은 우측 방향으로 진행된다.
- 괄호 안의 연산이 가장 우선되며, 단항, 이항 연산의 순으로 진행
- 곱셉과 나눗셈이 덧셈, 뺄셈보다 먼저 진행된다.
- 다른 타입의 피연산자일 경우 더 크고 정밀한 타입의 피연산자 타입으로 값이 나옴

`위에서 아래로 우선순위가 낮아짐 단산시관비논복`

| 연산자  | 종류                             | 결합 방향 |
|------|--------------------------------|-------|
| 단항   | `++, --, -, !, ~, sizeof, &, *` | ←     |
| 산술   | `*, /, %, +, -`                | →     |
| 시프트  | `<<, >>`                       | →     |
| 관계   | `<, >, <=, =>, ==, !=`         | →     |
| 비트   | `&, ^, |`                        | →     |
| 논리   | `&&, ||`                       | →     |
| 복합대입 | `=, +=, -+, *=, /=, %=, <<=, >>=` | ←     |

---

## C언어
### 논리연산자
C언어에서 논리 연산자(`&&`, `||`, `!`) 는 숫자가 0인지 아닌지를 판별하는 것이다.

```c
int a = 5, b = 3, c = 12;
int r1, r2, r3;

r1 = a && b; //둘 다 0이 아니므로 1
r2 = a || b; //둘 중 하나라도 0이 아니면 1이므로 1
r3 = !c // c는 0이 아니므로 true이지만, !을 붙였으므로 false 
```

### C언어 표준 라이브러리
1. 데이터 입출력: `stdio.h`
2. 수학: `math.h`
3. 문자열 처리: `string.h`
4. 기본 데이터 관련: `stdlib.h`

### 메모리 동적 할당
1. **malloc(크기)**: 메모리를 할당
2. **free(포인터)**: 사용이 끝난 메모리를 해제
3. **calloc**: 할당과 동시에 0으로 초기화
4. **realloc**: 이미 할당된 크기를 변경

### 배열

{% raw %}
```c
// 자료형 배열명[크기] = {데이터1, 데이터2, ...};
int arr[5] = {1, 2, 3, 4, 5};

// 2차원 배열 자료형 배열명[행][열] 
int arr[5][3] = {{1,2,3,4,5}, {6,7,8,9,10}, {11,12,13,14,15}};
```
{% endraw %}

### 구조체
`struct` 키워드를 사용하며, 중괄호 `{}` 안에 서로 다른 자료형의 변수를 담는 것.

{% raw %}
```c
// 구조체 선언
struct Student {
	char name[20];
	int score;
};

// 선언 및 초기화
struct Student s1 = {"홍길동", 95};

// 멤버 접근 (점. 연산자)
int num = s1.score;

// 구조체 배열
struct Student class[3] = {{"Kim", 80}, {"Lee", 90}, {"Park", 70}};
```
{% endraw %}

### 비트 필드
정수 타입의 멤버 변수를 비트 단위로 쪼개서 사용할 수 있게 하는 방법
- 비트의 수는 지정한 정수 타입보다 클 수 없다
- 비트 필드 구조체의 크기는 정수 타입 단위로 증가
- 여러 타입이 있는 경우에는 가장 큰 타입을 기준으로 증가

### 포인터
메모리 주소를 저장하는 변수. 이를 통해서
1. `&(주소 연산자)`: 변수 앞에 `&`를 붙이면, 그 변수가 메모리 몇번지에 있는지를 나타냄
2. `*(포인터)`:
  - 선언할 때: 포인터 변수임을 선언
  - 사용할 때(역참조): 포인터 변수가 가리키는 **메모리 위치에 저장된 내용(데이터)에 접근**

```c
int a = 10; // 변수 a에 10 저장
int *p = &a; // 포인터 p에 a의 주소(100)를 저장
*p = 20; // 변수 a의 주소에 접근하여, a의 값을 20으로 변경 
```

#### 참조에 의한 전달
인수 전달 시 복사된 데이터를 전달하는 것이 아닌 참조(위치)값을 전달함으로써 데이터 원본을 가공할 수 있다.

```c
void fa(int x, int *y) {
	x = x + 5; // x는 n에게 데이터를 전달 받아서 계산만 수행하고 끝
	*y = *y + 5; // y는 k의 주소값을 전달 받았으므로, 연산 후에 k의 데이터가 변경됨
	return;
}

int main() {
	int n=10, k=20;
	fa(n, &k); // 변수 n의 데이터 값 10과 k의 주소 값을 전달
	printf("%d %d", n, k); // 10, 25
	return 0;
}
```

#### 배열과 포인터
배열의 이름은 배열의 첫 번째 요소의 시작 주소를 의미함

```c
int a[3] = {10, 20, 30}; 
// 배열명 a는 첫 번째 요소의 주소를 의미함 
// 10(100), 20(101), 30(102)
int *p = a; // 포인터 p에 배열의 시작 주소를 대입

// 출력: 10, p가 가리키는 주소(100)의 값을 가져옴 (*p == a[0])
printf("%d \n", *p); 

// 출력: 11, *p(값 10)를 먼저 가져온 뒤 1을 더함 (10 + 1)
printf("%d \n", *p+1); 

// 출력: 20, 주소(100)에 1을 더해 다음 주소로 이동한 뒤, 그 곳의 값을 가져옴
// 포인터 기호가 붙어 있지 않은 경우에는 주소 값 자체를 의미함!
printf("%d \n", *(p+1));
```

> - x행 y열의 2차원 배열이 있을 때, `(*p)[y]`은 y개 단위, 즉 한개의 행단위로 움직인다는 뜻 
> - 그렇기에 `*(*(p+i)+j)` 는 `p[i][j]` 와 같다.
> - 단순히 `*p=배열`과 선언하면, `배열[0][0]`의 주소값이 할당되어 그 지점부터 시작하게 된다.


#### 구조체와 포인터
- 멤버 접근 연산자(`->`): 포인터로 구조체 내부 데이터에 접근할 때 쓰는 기호

{% raw %}
```c
struct Student {
	int id;
	int score;
};

struct Student s[3] = {{1, 80}, {2, 90}, {3, 60}};
struct Student *p = s; // p는 s[0]의 주소를 가리킴

printf("%d", p->id); // 출력: 1
p++; // 포인터 p의 주소 값이 증가. 즉, 다음 구조체(s[1])로 이동
printf("%d", p->score);  // 출력: 90
```
{% endraw %}

---

## 파이썬

### 표준 입출력 함수
1. `input()`: 키보드를 통해 데이터를 입력받는 함수
2. `print(값1, 값2, sep=구분자, end=종료자)`: 데이터를 출력한 뒤 줄바꿈을 하는 함수
  - **sep**: 값들 사이를 채울 문자 (기본 값은 " " 공백. 자동으로 띄어쓰기가 됨)
  - **end**: 출력이 끝난 후 붙을 문자 (기본 값은 `\n` 줄바꿈)

```python
#input(prompt)
name = input("이름을 입력하세요:" )

#정수형으로 변환하고 싶을 때 int(input(prompt))
age = int(input("나이를 입력하세요: "))

#실수형으로 변환하고 싶을 때 float(input(prompt))
sight = float(input("시력을 입력하세요: "))


print("A", "B", "C", "D", "E")
print("A", "B", "C", "D", "E", sep=",", end="끝")
#출력
#A B C D E → 자동으로 띄어쓰기가 됨
#A,B,C,D,E끝 → 줄바꿈되어 다음 줄부터 출력됨.
#만약 print 여러개를 한 줄로 출력하고 싶을 땐 end의 값을 " " 공백으로 입력
```

### 연산자
파이썬 전용 연산자가 존재
- `//`: 몫 (C언어와 자바는 타입이 명시되어 있기 때문에 int에 담으면 몫이 자동으로 구해지지만, 파이썬은 값에 따라 타입이 정해지므로 몫을 계산하는 연산자가 별도로 필요)
- `%`: 나머지
- `**`: 제곱 (C언어와 자바에서는 `pow()` 라는 함수를 사용)

### 논리 연산자
파이썬은 하나의 데이터에 대한 두 개의 비교 연산을 동시에 처리 할 수 있음

```python
#a가 0보다 크고 10보다는 작다
#C언어나 Java의 경우 (0 < a && a < 10) &&(and)로 묶어줘야함
#파이썬은 연산자 체이닝을 통해 간편하게 표현가능
a = 10
b = 20
flag = False
print(0 < a < 10)

#직접적으로 명시해야 할 경우에는 and, or, not을 사용
print(a <= 10 and b <=20) #true
print(a > b or b > a) #true
print(not flag) #true
```

### 시퀀스 자료 구조
하나의 식별자로 서로 다른 타입의 다수 데이터를 관리할 수 있는 자료구조
- **리스트**: 가변형(수정 가능), 대괄호`[]`로 표현
- **튜플**: 불변형(수정 불가능), 소괄호`()`로 표현
- **문자열**: 불변형(수정 불가능), 따옴표`""`로 표현

```python
list = [10, 20, 30, 40, 50] #리스트
tuple = (10, 20, 30, 40, 50) #튜플
str = "12345" #문자열

print(list) #출력: [10, 20, 30, 40, 50]
print(tuple) #출력: (10, 20, 30, 40, 50)
print(str) #출력: 12345
#리스트와 튜플은 출력시에 대괄호와 소괄호가 붙음!!!

#리스트의 삽입과 수정
list.append(60) #삽입
list[3] = 80 #수정

print(list) #출력: [10, 20, 30, 80, 50, 60]

#튜플과 문자열은 조회만 가능!
print(tuple[0]) #10
print(str[0]) #1
```

#### 인덱싱
첨자를 사용하여 시퀀스 요소 중 하나에 접근할 수 있는 기술
- **정방향**: 0부터 시작
- **역방향**: 데이터의 총 길이에 마이너스(`-`)를 붙인 값부터 시작하며 -1씩 증가

```python
list = [10, 20, 30, 40, 50] #리스트
tuple = (10, 20, 30, 40, 50) #튜플
str = "12345" #문자열
#정방향 0, 1, 2, 3, 4
#역방향 -5, -4, -3, -2, -1

print(tuple[-1]) #50
print(list[-5]) #10
print(str[-1]) #5
```

#### 슬라이싱
2개의 첨자를 사용하여 하나 이상의 시퀀스 요소에 접근할 수 있는 기술. 순서가 있음음
- `변수명 [start : stop : step]`
- **start**: 시작할 인덱스(포함 됨)
- **stop**: 끝낼 인덱스(포함되지 않음. 직전에서 잘림)
- **step**: 보폭(기본값은 1, 몇 칸씩 건너뛸지 결정)

```python
s = "Hello World" 
#총 길이: 11
#H e l l o   W o r l d
#0 1 2 3 4 5 6 7 8 9 10

print(s[0:10]) #Hello Worl → 0부터 9까지 출력(끝 인덱스는 포함되지 않음)
print(s[0:11:2]) #HloWrd → 0부터 2개씩 건너뛰어서 출력 
print(s[::-1]) #dlroW olleH → 역순으로 출력
```

#### 리스트 관련 함수 - 요소 추가 및 삭제
- **append(x)**: 리스트 맨 뒤에 요소 x를 추가
- **insert(i, x)**: i번 인덱스 위치에 x를 삽입 (뒤에 요소들은 밀려남)
- **extend(list)**: 리스트 뒤에 다른 리스트를 합침
- **pop(i)**: i번 인덱스 요소를 꺼내고(삭제) 그 값을 반환
- **del 리스트[i]**: i번 인덱스 요소를 삭제
- **remove(x)**: 리스트에서 값이 x인 첫 번째 요소를 삭제
- **clear()**: 리스트의 모든 요소 삭제

```python
s = ["A", "B", "A", "A", "C"]
a = [10, 20, 30, 40, 50]

# ----------- remove + pop : 요소 삭제 -----------
s.remove("A") 
print(s.pop(0)) #출력: B
del s[0]

print(s) #출력: ['A', 'C'] 
#remove는 중복된 요소들 중 가장 앞에 있는 값을 삭제 
#pop은 특정 위치의 요소를 삭제 후 반환
#del 특정 위치의 요소를 삭제
#A가 0, 2, 3번 인덱스에 위치해 있을 때 0번째 'A'가 삭제됨 → B, A, A, C
#pop으로 0번째 요소를 삭제 → A, A, C
#del을 통해 다시 0버째 요소를 삭제 → A, C

# ----------- append + insert : 요소 삽입 -----------
s.append(60)
s.insert(0, 100)

print(s) #출력: [100, 'A', 'C', 60] → 0번째와 마지막에 새로운 요소가 삽입됨

# ----------- extend : 리스트 + 리스트 -----------
s.extend(a)

print(s) #출력: [100, 'A', 'C', 60, 10, 20, 30, 40, 50] → 리스트 s와 a가 합쳐짐

# ----------- clear : 모든 리스트 요소 삭제 -----------
s.clear()

print(s) #출력: [] → 모든 요소가 삭제됨
```

#### 리스트 관련 함수 - 정렬 및 순서 변경
- **sort()**: 리스트 자체를 오름차순으로 정렬 (내림차순 시 `sort(reverse=True)`)
- **reverse()**: 리스트의 순서를 거꾸로 뒤집음 (정렬은 아님)
- **sorted(list)**: 리스트의 원본을 유지하고 사본을 만들어 정렬 및 반전

```python
a = [12, 55, 80, 3, 46]
b = s.sorted()

# ----------- sort : 정렬 -----------
a.sort
print(a) #출력: [3, 12, 46, 55, 80]

a.sort(reverse=True)
print(a) #출력: [80, 55, 46, 12, 3]

# ----------- reverse : 역방향 -----------
a.reverse()
print(a) #출력: [3, 12, 46, 55, 80] → 이전에 정렬되었던 것에 영향을 받음 원래는 정렬 안됨

# ----------- sorted : 사본 -----------
print(b) #출력: [3, 12, 46, 55, 80] → 정렬된 후에 사본으로 저장됨
```

#### 리스트 관련 함수 - 정보 조회 및 기타
- **index(x)**: 값 x가 있는 위치를 반환
- **count(x)**: 리스트에 값 x가 몇 개 있는지 개수를 셈(중복 값 개수 반환)
- **len(list)**: 리스트의 전체 길이를 반환

### 매핑형 자료 구조
하나의 식별자로 서로 다른 타입의 다수 데이터를 관리할 수 있는 순서가 없는 자료구조

#### 딕셔너리
중괄호 `{ }`를 사용하며, `키: 값` 형태로 데이터를 저장
- **keys()**: 모든 키만 모아서 반환
- **values()**: 모든 값만 모아서 반환
- **items()**: (키, 값)의 쌍을 튜플로 묶어서 반환
- **get(key)**: 특정 키의 값을 가져옴
- **del 변수명[key]**: 특정 요소를 삭제
- **clear()**: 모든 요소를 삭제

```python
d = {"name": "홍길동", "age": 34}

print(d) #출력: {'name': '홍길동', 'age': 34} → 중괄호가 붙어서 출력됨!!
```

### 반복문
파이썬에서 반복문은 반복 가능한 객체(iterable)에서 요소를 하나씩 꺼내오는 방식. 단순히 자료형 내의 데이터를 순차적으로 꺼낼 때는 `for ~ in`을 사용하며, 특정 범위나 반복 횟수가 정해진 경우에는 `range()`를 사용 (해당 범위를 하나의 덩어리로 묶는 다는 것)

```python
#for ~ in 
a = [1, 2, 3, 4, 5]
for i in a:
	print(i)

#특정 범위: range(시작값, 종료값, 증가값)
for i in range(0, 10, 1):
	print(i) #0부터 9까지 출력
```

### 함수
함수는 `def` 키워드를 사용하여 정의

### 클래스
- **클래스 생성**: `class` 키워드 사용. 인스턴스 생성 시 단순히 클래스명만 입력
- **self**: 자바에서 `this`의 역할. 인스턴스 메서드를 선언할 때 첫번째 매개변수로 반드시 사용
- **생성자**: 다음과 같은 형식을 지켜야함 `def __init__(self):`
- **private 변수**: 언더바 두개 붙여서 선언(`__`)
- **상속**: `class 자식클래스(부모클래스)` (오버라이딩도 가능)
- **super()**: 상위 클래스의 생성자 호출

```python
class Car:
	#클래스 변수: 모든 인스턴스에서 접근 가능
    color = "색상없음"

    def __init__(self):
        self.color = "검은색" 
    
    def changeColor(self, color): 
        self.color = color
        
car = Car()
print(car.color) #출력: 검은색

car.changeColor("빨간색")
print(car.color) #출력: 빨간색
```
